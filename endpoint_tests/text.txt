Frontend кодовая база
=== Файл: App.css ===
```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
```

=== Файл: vite-env.d.ts ===
```typescript
/// <reference types="vite/client" />
```

=== Файл: App.tsx ===
```typescript
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { RouterProvider, createBrowserRouter } from 'react-router-dom'
import './styles/base.css'

const queryClient = new QueryClient({
	defaultOptions: {
		queries: {
			refetchOnWindowFocus: false,
			retry: 1,
		},
	},
})

const router = createBrowserRouter([
	{
		path: '/',
		element: <div>Pet Health App</div>,
	},
])

export function App() {
	return (
		<QueryClientProvider client={queryClient}>
			<RouterProvider router={router} />
			<ReactQueryDevtools initialIsOpen={false} />
		</QueryClientProvider>
	)
}
```

=== Файл: main.tsx ===
```typescript
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { App } from './App.tsx'
import './index.css'

createRoot(document.getElementById('root')!).render(
	<StrictMode>
		<App />
	</StrictMode>
)
```

=== Файл: index.css ===
```css
:root {
  font-family: system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}
```

=== Файл: features/diary/hooks/useDiary.ts ===
```typescript
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { useToken } from '../../auth/hooks/useToken'
import { diaryApi } from '../api/diaryApi'
import { StatusLogCreateRequest, StatusLogUpdateRequest } from '../api/types'

export const useDiary = (animalId: number) => {
	const queryClient = useQueryClient()
	const { getAccessToken } = useToken()

	// Получение всех записей
	const statusLogsQuery = useQuery({
		queryKey: ['animalStatusLogs', animalId],
		queryFn: () => diaryApi.getStatusLogs(animalId),
		enabled: !!animalId && !!getAccessToken(),
	})

	// Создание записи
	const createMutation = useMutation({
		mutationFn: (data: StatusLogCreateRequest) =>
			diaryApi.createStatusLog(animalId, data),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: ['animalStatusLogs', animalId],
			})
		},
	})

	// Обновление записи
	const updateMutation = useMutation({
		mutationFn: ({
			statusLogId,
			data,
		}: {
			statusLogId: number
			data: StatusLogUpdateRequest
		}) => diaryApi.updateStatusLog(animalId, statusLogId, data),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: ['animalStatusLogs', animalId],
			})
		},
	})

	// Удаление записи
	const deleteMutation = useMutation({
		mutationFn: (statusLogId: number) =>
			diaryApi.deleteStatusLog(animalId, statusLogId),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: ['animalStatusLogs', animalId],
			})
		},
	})

	return {
		statusLogs: statusLogsQuery.data,
		isLoading: statusLogsQuery.isLoading,
		refetchStatusLogs: statusLogsQuery.refetch,

		createStatusLog: createMutation.mutateAsync,
		isCreating: createMutation.isPending,

		updateStatusLog: updateMutation.mutateAsync,
		isUpdating: updateMutation.isPending,

		deleteStatusLog: deleteMutation.mutateAsync,
		isDeleting: deleteMutation.isPending,
	}
}
```

=== Файл: features/diary/hooks/useDiaryFiles.ts ===
```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { diaryApi } from '../api/diaryApi'

export const useDiaryFiles = (animalId: number, statusLogId: number) => {
	const queryClient = useQueryClient()

	const addPhoto = useMutation({
		mutationFn: (file: File) =>
			diaryApi.addStatusLogPhoto(animalId, statusLogId, file),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: ['animalStatusLogs', animalId],
			})
		},
	})

	const deletePhoto = useMutation({
		mutationFn: (photoId: number) => diaryApi.deleteStatusLogPhoto(photoId),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: ['animalStatusLogs', animalId],
			})
		},
	})

	const addDocument = useMutation({
		mutationFn: ({ file, type }: { file: File; type: string }) =>
			diaryApi.addStatusLogDocument(animalId, statusLogId, file, type),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: ['animalStatusLogs', animalId],
			})
		},
	})

	const deleteDocument = useMutation({
		mutationFn: (documentId: number) =>
			diaryApi.deleteStatusLogDocument(documentId),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: ['animalStatusLogs', animalId],
			})
		},
	})

	return {
		addPhoto: addPhoto.mutateAsync,
		isAddingPhoto: addPhoto.isPending,

		deletePhoto: deletePhoto.mutateAsync,
		isDeletingPhoto: deletePhoto.isPending,

		addDocument: addDocument.mutateAsync,
		isAddingDocument: addDocument.isPending,

		deleteDocument: deleteDocument.mutateAsync,
		isDeletingDocument: deleteDocument.isPending,
	}
}
```

=== Файл: features/diary/hooks/useDiaryAttributes.ts ===
```typescript
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { AttributeRequest } from '../../animal/api/types'
import { useToken } from '../../auth/hooks/useToken'
import { diaryApi } from '../api/diaryApi'

export const useDiaryAttributes = (animalId: number, statusLogId?: number) => {
	const queryClient = useQueryClient()
	const { getAccessToken } = useToken()

	// История атрибутов животного
	const attributeHistoryQuery = useQuery({
		queryKey: ['animalAttributeHistory', animalId],
		queryFn: () => diaryApi.getAttributeHistory(animalId),
		enabled: !!animalId && !!getAccessToken(),
	})

	// Операции с атрибутами записи
	const addAttribute = useMutation({
		mutationFn: (data: AttributeRequest) =>
			diaryApi.addStatusLogAttribute(animalId, statusLogId!, data),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: ['animalStatusLogs', animalId],
			})
		},
	})

	const updateAttribute = useMutation({
		mutationFn: ({
			attributeId,
			data,
		}: {
			attributeId: number
			data: AttributeRequest
		}) =>
			diaryApi.updateStatusLogAttribute(
				animalId,
				statusLogId!,
				attributeId,
				data
			),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: ['animalStatusLogs', animalId],
			})
			queryClient.invalidateQueries({
				queryKey: ['animalAttributeHistory', animalId],
			})
		},
	})

	const deleteAttribute = useMutation({
		mutationFn: (attributeId: number) =>
			diaryApi.deleteStatusLogAttribute(animalId, statusLogId!, attributeId),
		onSuccess: () => {
			queryClient.invalidateQueries({
				queryKey: ['animalStatusLogs', animalId],
			})
			queryClient.invalidateQueries({
				queryKey: ['animalAttributeHistory', animalId],
			})
		},
	})

	return {
		attributeHistory: attributeHistoryQuery.data,
		isLoadingHistory: attributeHistoryQuery.isLoading,

		addAttribute: addAttribute.mutateAsync,
		isAddingAttribute: addAttribute.isPending,

		updateAttribute: updateAttribute.mutateAsync,
		isUpdatingAttribute: updateAttribute.isPending,

		deleteAttribute: deleteAttribute.mutateAsync,
		isDeletingAttribute: deleteAttribute.isPending,
	}
}
```

=== Файл: features/diary/api/types.ts ===
```typescript
import {
	AttributeRequest,
	AttributeResponse,
	DocumentResponse,
} from '../../animal/api/types'

export interface StatusLogCreateRequest {
	notes?: string
	logDate?: string // ISO date
	attributes?: AttributeRequest[]
}

export interface StatusLogUpdateRequest {
	notes?: string
	logDate?: string
}

export interface StatusLogResponse {
	id: number
	logDate: string
	notes?: string
	photos: string[] // objectKeys
	documents: DocumentResponse[]
	attributes: AttributeResponse[]
}

export interface AttributeHistoryResponse {
	attributeName: string
	oldValue?: string
	changedAt: string
	changedBy: string
}

export interface StatusLogWithHistory extends StatusLogResponse {
	attributeHistory: AttributeHistoryResponse[]
}
```

=== Файл: features/diary/api/diaryApi.ts ===
```typescript
import { apiClient } from '../../../api/client'
import { AttributeRequest } from '../../animal/api/types'
import {
	AttributeHistoryResponse,
	StatusLogCreateRequest,
	StatusLogResponse,
	StatusLogUpdateRequest,
	StatusLogWithHistory,
} from './types'

export const diaryApi = {
	// Основные операции с записями
	createStatusLog: (animalId: number, data: StatusLogCreateRequest) =>
		apiClient
			.post<StatusLogResponse>(`/animals/${animalId}/status-logs`, data)
			.then(r => r.data),

	getStatusLog: (animalId: number, statusLogId: number) =>
		apiClient
			.get<StatusLogWithHistory>(
				`/animals/${animalId}/status-logs/${statusLogId}`
			)
			.then(r => r.data),
	getStatusLogs: (animalId: number) =>
		apiClient
			.get<StatusLogResponse[]>(`/animals/${animalId}/status-logs`)
			.then(r => r.data),
	updateStatusLog: (
		animalId: number,
		statusLogId: number,
		data: StatusLogUpdateRequest
	) =>
		apiClient
			.put<StatusLogResponse>(
				`/animals/${animalId}/status-logs/${statusLogId}`,
				data
			)
			.then(r => r.data),

	deleteStatusLog: (animalId: number, statusLogId: number) =>
		apiClient
			.delete(`/animals/${animalId}/status-logs/${statusLogId}`)
			.then(r => r.data),

	// Файлы записей
	addStatusLogPhoto: (animalId: number, statusLogId: number, file: File) => {
		const formData = new FormData()
		formData.append('file', file)
		return apiClient
			.post(
				`/animals/${animalId}/status-logs/${statusLogId}/photos`,
				formData,
				{ headers: { 'Content-Type': 'multipart/form-data' } }
			)
			.then(r => r.data)
	},

	deleteStatusLogPhoto: (photoId: number) =>
		apiClient
			.delete(`/animals/status-logs/photos/${photoId}`)
			.then(r => r.data),

	addStatusLogDocument: (
		animalId: number,
		statusLogId: number,
		file: File,
		type: string
	) => {
		const formData = new FormData()
		formData.append('file', file)
		formData.append('type', type)
		return apiClient
			.post(
				`/animals/${animalId}/status-logs/${statusLogId}/documents`,
				formData,
				{ headers: { 'Content-Type': 'multipart/form-data' } }
			)
			.then(r => r.data)
	},

	deleteStatusLogDocument: (documentId: number) =>
		apiClient
			.delete(`/animals/status-logs/documents/${documentId}`)
			.then(r => r.data),

	// Атрибуты записей
	addStatusLogAttribute: (
		animalId: number,
		statusLogId: number,
		data: AttributeRequest
	) =>
		apiClient
			.post(`/animals/${animalId}/status-logs/${statusLogId}/attributes`, data)
			.then(r => r.data),

	updateStatusLogAttribute: (
		animalId: number,
		statusLogId: number,
		attributeId: number,
		data: AttributeRequest
	) =>
		apiClient
			.patch(
				`/animals/${animalId}/status-logs/${statusLogId}/attributes/${attributeId}`,
				data
			)
			.then(r => r.data),

	deleteStatusLogAttribute: (
		animalId: number,
		statusLogId: number,
		attributeId: number
	) =>
		apiClient
			.delete(
				`/animals/${animalId}/status-logs/${statusLogId}/attributes/${attributeId}`
			)
			.then(r => r.data),

	// Получение истории атрибутов
	getAttributeHistory: (animalId: number) =>
		apiClient
			.get<AttributeHistoryResponse[]>(
				`/animals/${animalId}/attributes/history`
			)
			.then(r => r.data),
}
```

=== Файл: features/auth/hooks/useAuth.ts ===
```typescript
import { useMutation } from '@tanstack/react-query'
import { authApi } from '../api/authApi'
import { useToken } from './useToken'

export const useAuth = () => {
	const { setTokens, clearTokens } = useToken()

	const registerMutation = useMutation({
		mutationFn: authApi.register,
	})

	const activateMutation = useMutation({
		mutationFn: authApi.activate,
	})

	const loginMutation = useMutation({
		mutationFn: authApi.login,
		onSuccess: data => {
			setTokens({
				accessToken: data.accessToken,
				refreshToken: data.refreshToken,
			})
		},
	})

	const logout = () => {
		clearTokens()
		// Дополнительные действия при выходе
	}

	return {
		register: registerMutation.mutateAsync,
		isRegistering: registerMutation.isPending,

		activate: activateMutation.mutateAsync,
		isActivating: activateMutation.isPending,

		login: loginMutation.mutateAsync,
		isLoggingIn: loginMutation.isPending,

		logout,
	}
}
```

=== Файл: features/auth/hooks/useToken.ts ===
```typescript
import { useEffect } from 'react'
import { apiClient } from '../../../api/client'

export const useToken = () => {
	const setTokens = (tokens: { accessToken: string; refreshToken: string }) => {
		localStorage.setItem('accessToken', tokens.accessToken)
		localStorage.setItem('refreshToken', tokens.refreshToken)
		apiClient.defaults.headers['Authorization'] = `Bearer ${tokens.accessToken}`
	}

	const clearTokens = () => {
		localStorage.removeItem('accessToken')
		localStorage.removeItem('refreshToken')
		delete apiClient.defaults.headers['Authorization']
	}

	const getAccessToken = () => localStorage.getItem('accessToken')

	// Инициализация при монтировании
	useEffect(() => {
		const token = localStorage.getItem('accessToken')
		if (token) {
			apiClient.defaults.headers['Authorization'] = `Bearer ${token}`
		}
	}, [])

	return { setTokens, clearTokens, getAccessToken }
}
```

=== Файл: features/auth/api/types.ts ===
```typescript
// Регистрация
export interface RegisterRequest {
	username: string
	email: string
	password: string
}

export interface RegisterResponse {
	email: string
	username: string
	isActivated: boolean
}

// Активация
export interface ActivateRequest {
	token: string
}

// Авторизация
export interface LoginRequest {
	identifier: string // email или username
	password: string
}

export interface Tokens {
	accessToken: string
	refreshToken: string
	accessExpiresAt: string
	refreshExpiresAt: string
}

export interface LoginResponse extends Tokens {
	user: {
		email: string
		username: string
	}
}
```

=== Файл: features/auth/api/authApi.ts ===
```typescript
import { apiClient } from '../../../api/client'
import {
	LoginRequest,
	LoginResponse,
	RegisterRequest,
	RegisterResponse,
} from './types'

export const authApi = {
	register: (data: RegisterRequest) =>
		apiClient
			.post<RegisterResponse>('/auth/register', data)
			.then(response => response.data),

	activate: (token: string) =>
		apiClient
			.get<void>('/auth/activate-account', {
				params: { token },
			})
			.then(r => r.data),

	login: (data: LoginRequest) =>
		apiClient
			.post<LoginResponse>('/auth/authenticate', data)
			.then(response => response.data),
}
```

=== Файл: features/user/hooks/useUser.ts ===
```typescript
import { useMutation, useQuery } from '@tanstack/react-query'
import { userApi } from '../api/userApi'

export const useUser = () => {
	// Получение текущего пользователя
	const {
		data: currentUser,
		isLoading: isUserLoading,
		refetch: refetchUser,
	} = useQuery({
		queryKey: ['currentUser'],
		queryFn: userApi.getCurrentUser,
		staleTime: 5 * 60 * 1000, // 5 минут
	})

	// Обновление данных
	const updateMutation = useMutation({
		mutationFn: userApi.updateUser,
		onSuccess: () => refetchUser(),
	})

	// Загрузка фото
	const uploadPhotoMutation = useMutation({
		mutationFn: userApi.uploadPhoto,
		onSuccess: () => refetchUser(),
	})

	return {
		currentUser,
		isUserLoading,

		updateUser: updateMutation.mutateAsync,
		isUpdating: updateMutation.isPending,

		uploadPhoto: uploadPhotoMutation.mutateAsync,
		isUploading: uploadPhotoMutation.isPending,
	}
}
```

=== Файл: features/user/api/types.ts ===
```typescript
// Обновление данных пользователя
export interface UserUpdateRequest {
	firstName?: string
	lastName?: string
	city?: string
	aboutMe?: string
}

export interface UserResponse {
	username: string
	firstName?: string
	lastName?: string
	city?: string
	aboutMe?: string
	photoUrl?: string
}

// Загрузка фото
export interface S3FileResponse {
	objectKey: string
	presignedUrl: string
}
```

=== Файл: features/user/api/userApi.ts ===
```typescript
import { apiClient } from '../../../api/client'
import { S3FileResponse, UserResponse, UserUpdateRequest } from './types'

export const userApi = {
	getCurrentUser: () =>
		apiClient.get<UserResponse>('/users/me').then(r => r.data),

	updateUser: (data: UserUpdateRequest) =>
		apiClient.patch<UserResponse>('/users/me', data).then(r => r.data),

	uploadPhoto: (file: File) => {
		const formData = new FormData()
		formData.append('file', file)
		return apiClient
			.post<S3FileResponse>('/users/me/photo', formData, {
				headers: {
					'Content-Type': 'multipart/form-data',
				},
			})
			.then(r => r.data)
	},
}
```

=== Файл: features/animal/hooks/useAnimal.ts ===
```typescript

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { animalApi } from '../api/animalApi'
import { AnimalUpdateRequest } from '../api/types'
import { useToken } from '../../auth/hooks/useToken'

export const useAnimal = (animalId?: number) => {
	const queryClient = useQueryClient()
	const { getAccessToken } = useToken()

	// Получение данных животного
	const animalQuery = useQuery({
		queryKey: ['animal', animalId],
		queryFn: () => animalApi.getAnimal(animalId!),
		enabled: !!animalId && !!getAccessToken(),
		staleTime: 5 * 60 * 1000,
	})

	// Создание животного
	const createMutation = useMutation({
		mutationFn: animalApi.createAnimal,
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['userAnimals'] })
		},
	})

	// Обновление животного
	const updateMutation = useMutation({
		mutationFn: ({ id, data }: { id: number; data: AnimalUpdateRequest }) =>
			animalApi.updateAnimal(id, data),
		onSuccess: (_, { id }) => {
			queryClient.invalidateQueries({ queryKey: ['animal', id] })
		},
	})

	// Удаление животного
	const deleteMutation = useMutation({
		mutationFn: animalApi.deleteAnimal,
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['userAnimals'] })
		},
	})

	return {
		// Данные
		animalData: animalQuery.data,
		isLoading: animalQuery.isLoading,
		refetchAnimal: animalQuery.refetch,

		// Основные операции
		createAnimal: createMutation.mutateAsync,
		isCreating: createMutation.isPending,

		updateAnimal: updateMutation.mutateAsync,
		isUpdating: updateMutation.isPending,

		deleteAnimal: deleteMutation.mutateAsync,
		isDeleting: deleteMutation.isPending,
	}
}
```

=== Файл: features/animal/hooks/useAnalytics.ts ===
```typescript
import { useQuery } from '@tanstack/react-query'
import { useToken } from '../../auth/hooks/useToken'
import { analyticsApi } from '../api/analyticsApi'

export const useAnalytics = (animalId?: number) => {
	const { getAccessToken } = useToken()

	return useQuery({
		queryKey: ['animalAnalytics', animalId],
		queryFn: () => analyticsApi.getAnimalAnalytics(animalId!),
		enabled: !!animalId && !!getAccessToken(),
		select: data =>
			data.map(item => ({
				...item,
				changes: item.changes.map(change => ({
					...change,
					date: new Date(change.date).toLocaleDateString(),
				})),
			})),
	})
}
```

=== Файл: features/animal/hooks/useExport.ts ===
```typescript
import { useMutation } from '@tanstack/react-query'
import { exportApi } from '../api/exportApi'

export const useExport = () => {
	return useMutation({
		mutationFn: exportApi.exportAnimalToPdf,
		onSuccess: () => {
			// Можно добавить уведомление об успешном экспорте
			console.log('PDF exported successfully')
		},
		onError: error => {
			console.error('Export failed:', error)
		},
	})
}
```

=== Файл: features/animal/hooks/useUserAnimals.ts ===
```typescript
import { useQuery } from '@tanstack/react-query'
import { useToken } from '../../auth/hooks/useToken'
import { analyticsApi } from '../api/analyticsApi'

export const useUserAnimals = () => {
	const { getAccessToken } = useToken()

	return useQuery({
		queryKey: ['userAnimals'],
		queryFn: analyticsApi.getUserAnimals,
		enabled: !!getAccessToken(),
		staleTime: 5 * 60 * 1000, // 5 минут
	})
}
```

=== Файл: features/animal/hooks/useAnimalAttributes.ts ===
```typescript
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { animalApi } from '../api/animalApi'
import { AttributeRequest, AttributeResponse } from '../api/types'

export const useAnimalAttributes = (animalId: number) => {
	const queryClient = useQueryClient()

	const addAttribute = useMutation<AttributeResponse, Error, AttributeRequest>({
		mutationFn: data => animalApi.addAttribute(animalId, data),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['animal', animalId] })
		},
	})

	const updateAttribute = useMutation<
		AttributeResponse,
		Error,
		{ attrId: number; data: AttributeRequest }
	>({
		mutationFn: ({ attrId, data }) =>
			animalApi.updateAttribute(animalId, attrId, data),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['animal', animalId] })
		},
	})

	const deleteAttribute = useMutation<void, Error, number>({
		mutationFn: attrId => animalApi.deleteAttribute(animalId, attrId),
		onSuccess: () => {
			queryClient.invalidateQueries({ queryKey: ['animal', animalId] })
		},
	})

	return {
		addAttribute: addAttribute.mutateAsync,
		isAdding: addAttribute.isPending,

		updateAttribute: updateAttribute.mutateAsync,
		isUpdatingAttr: updateAttribute.isPending,

		deleteAttribute: deleteAttribute.mutateAsync,
		isDeletingAttr: deleteAttribute.isPending,
	}
}
```

=== Файл: features/animal/api/analyticsApi.ts ===
```typescript
import { apiClient } from '../../../api/client'
import { AnimalResponse } from './types'

export interface AnimalAnalyticsResponse {
	attributeName: string
	changes: {
		date: string
		value: string
		changedBy: string
	}[]
	stats?: {
		minValue: string
		maxValue: string
		avgValue: number
	}
}

export const analyticsApi = {
	getAnimalAnalytics: (animalId: number) =>
		apiClient
			.get<AnimalAnalyticsResponse[]>(`/animals/${animalId}/analytics`)
			.then(r => r.data),

	getUserAnimals: () =>
		apiClient.get<AnimalResponse[]>('/users/me/animals').then(r => r.data),
}
```

=== Файл: features/animal/api/types.ts ===
```typescript
// Основные типы
export interface AnimalCreateRequest {
	name: string
	description?: string
	birthDate?: string // ISO date string
	mass?: number
	attributes: AttributeRequest[]
}

export interface AnimalUpdateRequest {
	name?: string
	description?: string
	birthDate?: string
	mass?: number
}

export interface AnimalResponse {
	id: number
	name: string
	description?: string
	birthDate?: string
	mass?: number
	attributes: AttributeResponse[]
	photos: string[] // objectKeys
	documents: DocumentResponse[]
	statusLogs: StatusLogResponse[]
}

export interface AttributeRequest {
	name: string
	value: string
}

export interface AttributeResponse {
	id: number
	name: string
	value?: string
}

export interface DocumentResponse {
	id: number
	type: string
	objectKey: string
	documentName?: string
}

export interface StatusLogResponse {
	id: number
	logDate: string
	notes?: string
	photos: string[]
	documents: DocumentResponse[]
}

export interface S3FileResponse {
	objectKey: string
	presignedUrl: string
}
```

=== Файл: features/animal/api/exportApi.ts ===
```typescript
import { apiClient } from '../../../api/client'

export const exportApi = {
	exportAnimalToPdf: (animalId: number) =>
		apiClient
			.get(`/animals/${animalId}/export/pdf`, {
				responseType: 'blob',
				headers: {
					Accept: 'application/pdf',
				},
			})
			.then(response => {
				// Создаем URL для скачивания файла
				const url = window.URL.createObjectURL(new Blob([response.data]))
				const link = document.createElement('a')
				link.href = url
				link.setAttribute('download', `animal_${animalId}_report.pdf`)
				document.body.appendChild(link)
				link.click()
				document.body.removeChild(link)
				return response
			}),
}
```

=== Файл: features/animal/api/animalApi.ts ===
```typescript
import { apiClient } from '../../../api/client'
import {
	AnimalCreateRequest,
	AnimalResponse,
	AnimalUpdateRequest,
	AttributeRequest,
	AttributeResponse,
	S3FileResponse,
	StatusLogResponse,
} from './types'

export const animalApi = {
	// Основные операции
	createAnimal: (data: AnimalCreateRequest) =>
		apiClient.post<AnimalResponse>('/animals', data).then(r => r.data),

	getAnimal: (animalId: number) =>
		apiClient.get<AnimalResponse>(`/animals/${animalId}`).then(r => r.data),

	updateAnimal: (animalId: number, data: AnimalUpdateRequest) =>
		apiClient
			.patch<AnimalResponse>(`/animals/${animalId}`, data)
			.then(r => r.data),

	deleteAnimal: (animalId: number) =>
		apiClient.delete(`/animals/${animalId}`).then(r => r.data),

	// Атрибуты
	addAttribute: (animalId: number, data: AttributeRequest) =>
		apiClient
			.post<AttributeResponse>(`/animals/${animalId}/attributes`, data)
			.then(r => r.data),

	updateAttribute: (
		animalId: number,
		attributeId: number,
		data: AttributeRequest
	) =>
		apiClient
			.patch<AttributeResponse>(
				`/animals/${animalId}/attributes/${attributeId}`,
				data
			)
			.then(r => r.data),

	deleteAttribute: (animalId: number, attributeId: number) =>
		apiClient
			.delete(`/animals/${animalId}/attributes/${attributeId}`)
			.then(r => r.data),

	// Фото
	uploadAnimalPhoto: (animalId: number, file: File) => {
		const formData = new FormData()
		formData.append('file', file)
		return apiClient
			.post<S3FileResponse>(`/animals/${animalId}/photos`, formData, {
				headers: { 'Content-Type': 'multipart/form-data' },
			})
			.then(r => r.data)
	},

	deleteAnimalPhoto: (photoId: number) =>
		apiClient.delete(`/animals/photos/${photoId}`).then(r => r.data),

	// Документы
	uploadAnimalDocument: (animalId: number, file: File, type: string) => {
		const formData = new FormData()
		formData.append('file', file)
		formData.append('type', type)
		return apiClient
			.post<S3FileResponse>(`/animals/${animalId}/documents`, formData, {
				headers: { 'Content-Type': 'multipart/form-data' },
			})
			.then(r => r.data)
	},

	deleteAnimalDocument: (documentId: number) =>
		apiClient.delete(`/animals/documents/${documentId}`).then(r => r.data),

	// История состояний
	getStatusLogs: (animalId: number) =>
		apiClient
			.get<StatusLogResponse[]>(`/animals/${animalId}/status-logs`)
			.then(r => r.data),

}
```

=== Файл: styles/base.css ===
```css
@import 'variables.css';

:root {
	font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
	line-height: 1.5;
	font-weight: 400;
	color-scheme: light dark;
}

body {
	margin: 0;
	min-width: 320px;
	min-height: 100vh;
}
```

=== Файл: api/client.ts ===
```typescript
import axios from 'axios'

export const apiClient = axios.create({
	baseURL: import.meta.env.VITE_API_URL || '/api',
	withCredentials: true,
	headers: {
		'Content-Type': 'application/json',
	},
})

// Интерсептор для ошибок
apiClient.interceptors.response.use(
	response => response,
	error => {
		if (error.response?.status === 401) {
			// TODO: Добавить обработку refresh токена
		}
		return Promise.reject(error)
	}
)

// Инициализация токена при старте
const token = localStorage.getItem('accessToken')
if (token) {
	apiClient.defaults.headers['Authorization'] = `Bearer ${token}`
}
```

Backend кодовая база
=== Файл: UserServiceApplication.kt ===
```kotlin
package ru.animaltracker.userservice

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication

@SpringBootApplication
class UserServiceApplication

fun main(args: Array<String>) {
    runApplication<UserServiceApplication>(*args)
}
```

=== Файл: pdfexport/PdfExporter.kt ===
```kotlin
package ru.animaltracker.userservice.pdfexport

import com.itextpdf.io.source.ByteArrayOutputStream
import com.itextpdf.kernel.pdf.PdfDocument
import com.itextpdf.kernel.pdf.PdfWriter
import com.itextpdf.layout.Document
import com.itextpdf.layout.element.Paragraph
import com.itextpdf.layout.properties.TextAlignment
import org.springframework.stereotype.Component
import ru.animaltracker.userservice.entity.Animal

@Component
class PdfExporter {
    fun exportAnimal(animal: Animal): ByteArray {
        ByteArrayOutputStream().use { outputStream ->
            PdfDocument(PdfWriter(outputStream)).use { pdfDoc ->
                Document(pdfDoc).use { doc ->

                    doc.add(
                        Paragraph("Данные о животном")
                        .setTextAlignment(TextAlignment.CENTER)
                        .setFontSize(20f))

                    doc.add(Paragraph("Основная информация:").setBold())
                    addKeyValue(doc, "Имя", animal.name)
                    addKeyValue(doc, "Описание", animal.description)
                    addKeyValue(doc, "Дата рождения", animal.birthDate?.toString())
                    addKeyValue(doc, "Вес", animal.mass?.toString())

                    doc.add(Paragraph("Атрибуты:").setBold())
                    animal.attributes.forEach { attr ->
                        attr.name?.let { addKeyValue(doc, it, attr.values.firstOrNull()?.value) }
                    }

                    doc.add(Paragraph("История изменений:").setBold())
                    animal.statusLogs.sortedBy { it.logDate }.forEach { log ->
                        doc.add(Paragraph("${log.logDate}: ${log.notes}"))
                    }
                }
            }

            return outputStream.toByteArray()
        }
    }

    private fun addKeyValue(doc: Document, key: String, value: String?) {
        doc.add(Paragraph("$key: ${value ?: "не указано"}"))
    }
}
```

=== Файл: controller/UserController.kt ===
```kotlin
package ru.animaltracker.userservice.controller

import jakarta.validation.Valid
import org.springframework.http.MediaType
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import org.springframework.web.multipart.MultipartFile
import ru.animaltracker.userservice.dto.AnimalResponse
import ru.animaltracker.userservice.dto.S3FileResponse
import ru.animaltracker.userservice.dto.UserResponse
import ru.animaltracker.userservice.dto.UserUpdateRequest
import ru.animaltracker.userservice.service.interfaces.AnimalService
import ru.animaltracker.userservice.service.interfaces.UserService

@RestController
@RequestMapping("/api/users")
class UserController(
    private val userService: UserService,
    private val animalService: AnimalService
) {

    @GetMapping("/me")
     fun getCurrentUser(
        @RequestHeader("X-User-Name") username: String
    ): ResponseEntity<UserResponse> {
        return ResponseEntity.ok(userService.getUser(username))
    }

    @PatchMapping("/me")
     fun updateUser(
        @RequestHeader("X-User-Name") username: String,
        @Valid @RequestBody request: UserUpdateRequest
    ): ResponseEntity<UserResponse> {
        return ResponseEntity.ok(userService.updateUser(username, request))
    }

    @PostMapping("/me/photo", consumes = [MediaType.MULTIPART_FORM_DATA_VALUE])
     fun uploadUserPhoto(
        @RequestHeader("X-User-Name") username: String,
        @RequestParam("file") file: MultipartFile
    ): ResponseEntity<S3FileResponse> {
        return ResponseEntity.ok(userService.uploadUserPhoto(username, file))
    }

    @GetMapping("/me/animals")
     fun getUserAnimals(
        @RequestHeader("X-User-Name") username: String
    ): ResponseEntity<List<AnimalResponse>> {
        return ResponseEntity.ok(animalService.getUserAnimals(username))
    }
}
```

=== Файл: controller/AnimalController.kt ===
```kotlin
package ru.animaltracker.userservice.controller

import jakarta.validation.Valid
import org.springframework.http.HttpStatus
import org.springframework.http.MediaType
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import org.springframework.web.multipart.MultipartFile
import ru.animaltracker.userservice.dto.*
import ru.animaltracker.userservice.service.interfaces.AnimalService

@RestController
@RequestMapping("/api/animals")
class AnimalController(
    private val animalService: AnimalService
) {

    @PostMapping
     fun createAnimal(
        @RequestHeader("X-User-Name") username: String,
        @Valid @RequestBody request: AnimalCreateRequest
    ): ResponseEntity<AnimalResponse> {
        return ResponseEntity.ok(animalService.createAnimal(username, request))
    }

    @GetMapping("/{animalId}")
     fun getAnimal(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long
    ): ResponseEntity<AnimalResponse> {
        return ResponseEntity.ok(animalService.getAnimal(username, animalId))
    }

    @GetMapping("/{animalId}/status-logs")
     fun getAnimalStatusLogs(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long
    ): ResponseEntity<List<StatusLogResponse>>{
        return ResponseEntity.ok(animalService.getStatusLogs(username, animalId))
    }

    @DeleteMapping("/{animalId}")
     fun deleteAnimal(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long
    ): ResponseEntity<Void> {
        animalService.deleteAnimal(username, animalId)
        return ResponseEntity.noContent().build()
    }

    @PostMapping("/{animalId}/photos", consumes = [MediaType.MULTIPART_FORM_DATA_VALUE])
     fun uploadAnimalPhoto(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long,
        @RequestParam("file") file: MultipartFile
    ): ResponseEntity<S3FileResponse> {
        return ResponseEntity.ok(animalService.addAnimalPhoto(username, animalId, file))
    }

    @PostMapping("/{animalId}/documents", consumes = [MediaType.MULTIPART_FORM_DATA_VALUE])
     fun uploadAnimalDocument(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long,
        @RequestParam("file") file: MultipartFile,
        @RequestParam type: String
    ): ResponseEntity<S3FileResponse> {
        return ResponseEntity.ok(animalService.addAnimalDocument(username, animalId, file, type))
    }

    @PostMapping("/{animalId}/status-logs")
     fun addStatusLog(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long,
        @Valid @RequestBody request: StatusLogCreateRequest
    ): ResponseEntity<StatusLogResponse> {
        return ResponseEntity.ok(animalService.addStatusLog(username, animalId, request))
    }

    @PostMapping("/{animalId}/status-logs/{statusLogId}/photos", consumes = [MediaType.MULTIPART_FORM_DATA_VALUE])
     fun uploadStatusLogPhoto(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long,
        @PathVariable statusLogId: Long,
        @RequestParam("file") file: MultipartFile
    ): ResponseEntity<S3FileResponse> {
        return ResponseEntity.ok(animalService.addStatusLogPhoto(username, animalId, statusLogId, file))
    }

    @PostMapping("/{animalId}/status-logs/{statusLogId}/documents")
     fun uploadStatusLogDocument(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long,
        @PathVariable statusLogId: Long,
        @RequestParam("file") file: MultipartFile,
        @RequestParam type: String
    ): ResponseEntity<S3FileResponse> {
        return ResponseEntity.ok(animalService.addStatusLogDocument(username, animalId, statusLogId, file, type))
    }

    @GetMapping("/{animalId}/attributes/history")
     fun getAttributesHistory(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long
    ): ResponseEntity<List<AttributeHistoryResponse>> {
        return ResponseEntity.ok(animalService.getAnimalAttributesHistory(animalId))
    }

    @PatchMapping("/{animalId}")
     fun updateAnimal(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long,
        @Valid @RequestBody request: AnimalUpdateRequest
    ): ResponseEntity<AnimalResponse> {
        return ResponseEntity.ok(animalService.updateAnimal(username, animalId, request))
    }

    @PutMapping("/{animalId}/status-logs/{statusLogId}")
     fun updateStatusLog(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long,
        @PathVariable statusLogId: Long,
        @Valid @RequestBody request: StatusLogUpdateRequest
    ): ResponseEntity<StatusLogResponse> {
        return ResponseEntity.ok(
            animalService.updateStatusLog(username, animalId, statusLogId, request)
        )
    }

    @DeleteMapping("/{animalId}/status-logs/{statusLogId}")
     fun deleteStatusLog(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long,
        @PathVariable statusLogId: Long
    ): ResponseEntity<Void> {
        animalService.deleteStatusLog(username, animalId, statusLogId)
        return ResponseEntity.noContent().build()
    }

    @PatchMapping("/{animalId}/attributes/{attributeId}")
     fun updateAttribute(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long,
        @PathVariable attributeId: Short,
        @Valid @RequestBody request: AttributeUpdateRequest
    ): ResponseEntity<AttributeResponse> {
        return ResponseEntity.ok(
            animalService.updateAttribute(username, animalId, attributeId, request)
        )
    }

    @PostMapping("/{animalId}/attributes")
     fun addAttribute(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long,
        @Valid @RequestBody request: AttributeRequest
    ): ResponseEntity<AttributeResponse> {
        return ResponseEntity.status(HttpStatus.CREATED)
            .body(animalService.addAttribute(username, animalId, request))
    }

    @DeleteMapping("/{animalId}/attributes/{attributeId}")
     fun deleteAttribute(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long,
        @PathVariable attributeId: Short
    ): ResponseEntity<Void> {
        animalService.deleteAttribute(username, animalId, attributeId)
        return ResponseEntity.noContent().build()
    }

    @DeleteMapping("/photos/{photoId}")
     fun deleteAnimalPhoto(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable photoId: Long
    ): ResponseEntity<Void> {
        animalService.deleteAnimalPhoto(username, photoId)
        return ResponseEntity.noContent().build()
    }

    @DeleteMapping("/documents/{documentId}")
     fun deleteAnimalDocument(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable documentId: Long
    ): ResponseEntity<Void> {
        animalService.deleteAnimalDocument(username, documentId)
        return ResponseEntity.noContent().build()
    }

    @GetMapping("/{animalId}/analytics")
     fun getAnimalAnalytics(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long
    ): ResponseEntity<List<AnimalAnalyticsResponse>> {
        return ResponseEntity.ok(animalService.getAnimalAnalytics(animalId))
    }

    @GetMapping("/{animalId}/export/pdf")
     fun exportAnimalToPdf(
        @RequestHeader("X-User-Name") username: String,
        @PathVariable animalId: Long
    ): ResponseEntity<ByteArray> {
        val pdfBytes = animalService.exportAnimalToPdf(username, animalId)

        return ResponseEntity.ok()
            .header("Content-Type", "application/pdf")
            .header("Content-Disposition", "attachment; filename=animal_${animalId}.pdf")
            .body(pdfBytes)
    }
}
```

=== Файл: service/MessageConsumerService.kt ===
```kotlin
package ru.animaltracker.userservice.service

import com.fasterxml.jackson.databind.ObjectMapper
import org.springframework.kafka.annotation.KafkaListener
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import ru.animaltracker.userservice.dto.UserCreatedEvent
import ru.animaltracker.userservice.entity.User
import ru.animaltracker.userservice.repository.UserRepository
@Service
class MessageConsumerService(
    private val objectMapper: ObjectMapper,
    private val userRepository: UserRepository,
) {

    @KafkaListener(topics = ["user-created"])
    @Transactional
    fun listen(json: String) {
        val dto = objectMapper.readValue(json, UserCreatedEvent::class.java)

        if (userRepository.findByEmail(dto.email) == null) {
            userRepository.save(User().apply {
                email = dto.email
                username = dto.username
            })
        }
    }
}
```

=== Файл: service/impl/UserServiceImpl.kt ===
```kotlin
package ru.animaltracker.userservice.service.impl

import jakarta.persistence.EntityNotFoundException
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.multipart.MultipartFile
import ru.animaltracker.userservice.dto.S3FileResponse
import ru.animaltracker.userservice.dto.UserResponse
import ru.animaltracker.userservice.dto.UserUpdateRequest
import ru.animaltracker.userservice.entity.Photo
import ru.animaltracker.userservice.entity.UserPhoto
import ru.animaltracker.userservice.repository.PhotoRepository
import ru.animaltracker.userservice.repository.UserPhotoRepository
import ru.animaltracker.userservice.repository.UserRepository
import ru.animaltracker.userservice.service.interfaces.S3Service
import ru.animaltracker.userservice.service.interfaces.UserService

@Service
class UserServiceImpl(
    private val userRepository: UserRepository,
    private val s3Service: S3Service,
    private val photoRepository: PhotoRepository,
    private val userPhotoRepository: UserPhotoRepository
) : UserService {

    @Transactional
    override fun updateUser(username: String, request: UserUpdateRequest): UserResponse {
        val user = userRepository.findByUsername(username)
            ?: throw EntityNotFoundException("User not found")

        request.firstName?.let { user.firstName = it }
        request.lastName?.let { user.lastName = it }
        request.city?.let { user.city = it }
        request.aboutMe?.let { user.aboutMe = it }
        val savedUser = userRepository.save(user)
        return savedUser.toDto()
    }

    @Transactional(readOnly = true)
    override fun getUser(username: String): UserResponse {
        val user = userRepository.findByUsername(username)
            ?: throw EntityNotFoundException("User not found")

        return user.toDto()
    }

    @Transactional
    override fun uploadUserPhoto(username: String, file: MultipartFile): S3FileResponse {
        val user = userRepository.findByUsername(username)
            ?: throw EntityNotFoundException("User not found")

        // Удаляем старое фото если есть
        user.userPhotos.firstOrNull()?.let { userPhoto ->
            userPhoto.photo?.objectKey?.let { s3Service.deleteFile(it) }
            photoRepository.delete(userPhoto.photo ?: throw IllegalStateException("Photo not found"))
            userPhotoRepository.delete(userPhoto)
        }

        // Загружаем новое фото
        val objectKey = s3Service.uploadFile(file, "users/$username/photos")
        val photo = photoRepository.save(Photo().apply {
            this.objectKey = objectKey
        })

        // Создаем связь пользователя с фото
        userPhotoRepository.save(UserPhoto().apply {
            this.user = user
            this.photo = photo
        })

        return S3FileResponse(
            objectKey = objectKey,
            presignedUrl = s3Service.generatePresignedUrl(objectKey)
        )
    }
}
```

=== Файл: service/impl/S3ServiceImpl.kt ===
```kotlin
package ru.animaltracker.userservice.service.impl

import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Service
import org.springframework.web.multipart.MultipartFile
import ru.animaltracker.userservice.exception.FileProcessingException
import ru.animaltracker.userservice.exception.FileUploadException
import ru.animaltracker.userservice.service.interfaces.S3Service
import software.amazon.awssdk.core.sync.RequestBody
import software.amazon.awssdk.services.s3.S3Client
import software.amazon.awssdk.services.s3.model.GetObjectRequest
import software.amazon.awssdk.services.s3.model.PutObjectRequest
import software.amazon.awssdk.services.s3.presigner.S3Presigner
import java.time.Duration
import java.util.*


@Service
class S3ServiceImpl(
    private val s3Client: S3Client,
    private val s3Presigner: S3Presigner,
    @Value("\${s3.bucket}") private val bucket: String
) : S3Service {

    companion object {
        private const val DEFAULT_PRESIGNED_URL_DURATION_MINUTES = 15L
    }

    override  fun uploadFile(
        file: MultipartFile,
        prefix: String,
        metadata: Map<String, String>
    ): String {
        val objectKey = "$prefix/${UUID.randomUUID()}_${file.originalFilename?.replace(" ", "_")}"

        val putObjectRequest = PutObjectRequest.builder()
            .bucket(bucket)
            .key(objectKey)
            .contentType(file.contentType)
            .metadata(metadata)
            .build()

        try {
            s3Client.putObject(
                putObjectRequest,
                RequestBody.fromBytes(file.bytes)
            )
            return objectKey
        } catch (e: Exception) {
            throw FileUploadException("Failed to upload file: ${e.message}")
        }
    }

    override  fun generatePresignedUrl(objectKey: String, duration: Duration): String {
        try {
            val getObjectRequest = GetObjectRequest.builder()
                .bucket(bucket)
                .key(objectKey)
                .build()

            val presignedRequest = s3Presigner.presignGetObject { builder ->
                builder.getObjectRequest(getObjectRequest)
                    .signatureDuration(duration)
            }

            return presignedRequest.url().toString()
        } catch (e: Exception) {
            throw FileProcessingException("Failed to generate presigned URL: ${e.message}")
        }
    }

    override  fun generatePresignedUrl(objectKey: String): String {
        return generatePresignedUrl(objectKey, Duration.ofMinutes(DEFAULT_PRESIGNED_URL_DURATION_MINUTES))
    }

    override  fun deleteFile(objectKey: String) {
        try {
            s3Client.deleteObject { builder ->
                builder.bucket(bucket).key(objectKey)
            }
        } catch (e: Exception) {
            throw FileProcessingException("Failed to delete file: ${e.message}")
        }
    }

    override  fun getFileMetadata(objectKey: String): Map<String, String> {
        val response = s3Client.headObject {
            it.bucket(bucket).key(objectKey)
        }

        return response.metadata().mapValues { (_, value) ->
            value
        }
    }
}
```

=== Файл: service/impl/AnimalServiceImpl.kt ===
```kotlin
package ru.animaltracker.userservice.service.impl

import jakarta.persistence.EntityNotFoundException
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.multipart.MultipartFile
import ru.animaltracker.userservice.dto.*
import ru.animaltracker.userservice.entity.*
import ru.animaltracker.userservice.pdfexport.PdfExporter
import ru.animaltracker.userservice.repository.*
import ru.animaltracker.userservice.service.interfaces.AnimalService
import ru.animaltracker.userservice.service.interfaces.S3Service
import java.nio.file.AccessDeniedException
import java.time.LocalDate


@Service
class AnimalServiceImpl(
    private val userRepository: UserRepository,
    private val animalRepository: AnimalRepository,
    private val attributeRepository: AttributeRepository,
    private val documentRepository: DocumentRepository,
    private val photoRepository: PhotoRepository,
    private val animalPhotoRepository: AnimalPhotoRepository,
    private val statusLogRepository: AnimalStatusLogRepository,
    private val statusLogPhotoRepository: StatusLogPhotoRepository,
    private val statusLogDocumentRepository: StatusLogDocumentRepository,
    private val attributeValueHistoryRepository: AttributeValueHistoryRepository,
    private val s3Service: S3Service,
) : AnimalService {

    @Autowired
    private lateinit var pdfExporter: PdfExporter

    @Transactional(readOnly = true)
    override  fun exportAnimalToPdf(username: String, animalId: Long): ByteArray {
        val (_, animal) = validateUserAndAnimal(username, animalId)

        return pdfExporter.exportAnimal(animal)
    }

    @Transactional
    override fun createAnimal(username: String, request: AnimalCreateRequest): AnimalResponse {
        val user = userRepository.findByUsername(username)
            ?: throw EntityNotFoundException("User not found")

        val animal = Animal().apply {
            name = request.name
            description = request.description
            birthDate = request.birthDate
            mass = request.mass
        }

        val savedAnimal = animalRepository.save(animal)

        request.attributes.forEach { attrRequest ->
            val attribute = Attribute().apply {
                name = attrRequest.name
                this.animal = savedAnimal
                addValue(attrRequest.value)
            }
            attributeRepository.save(attribute)
        }

        user.addAnimal(savedAnimal)
        userRepository.save(user)

        return savedAnimal.toDto()
    }

    @Transactional
    override fun addAnimalPhoto(username: String, animalId: Long, file: MultipartFile): S3FileResponse {
        val (_, animal) = validateUserAndAnimal(username, animalId)

        val objectKey = s3Service.uploadFile(file, "animals/$animalId/photos")
        val photo = photoRepository.save(Photo().apply {
            this.objectKey = objectKey
        })

        animalPhotoRepository.save(AnimalPhoto().apply {
            this.animal = animal
            this.photo = photo
        })

        return S3FileResponse(objectKey, s3Service.generatePresignedUrl(objectKey))
    }

    @Transactional
    override fun addAnimalDocument(username: String, animalId: Long, file: MultipartFile, type: String): S3FileResponse {
        val (_, animal) = validateUserAndAnimal(username, animalId)

        val objectKey = s3Service.uploadFile(file, "animals/$animalId/documents")
        val document = documentRepository.save(Document().apply {
            this.type = type
            this.objectKey = objectKey
            this.documentName = file.originalFilename
            this.animal = animal
        })

        return S3FileResponse(objectKey, s3Service.generatePresignedUrl(objectKey))
    }

    @Transactional
    override fun addStatusLog(username: String, animalId: Long, request: StatusLogCreateRequest): StatusLogResponse {
        val (user, animal) = validateUserAndAnimal(username, animalId)

        val statusLog = statusLogRepository.save(AnimalStatusLog().apply {
            notes = request.notes
            logDate = request.logDate ?: LocalDate.now()
            this.animal = animal
            this.user = user
        })

        return statusLog.toDto()
    }

    @Transactional
    override fun addStatusLogPhoto(username: String, animalId: Long, statusLogId: Long, file: MultipartFile): S3FileResponse {
        val (_, _, statusLog) = validateUserAndStatusLog(username, animalId, statusLogId)

        val objectKey = s3Service.uploadFile(file, "animals/$animalId/status-logs/$statusLogId/photos")
        val photo = photoRepository.save(Photo().apply {
            this.objectKey = objectKey
        })

        statusLogPhotoRepository.save(StatusLogPhoto().apply {
            this.animalStatusLog = statusLog
            this.photo = photo
        })

        return S3FileResponse(objectKey, s3Service.generatePresignedUrl(objectKey))
    }

    @Transactional
    override fun addStatusLogDocument(username: String, animalId: Long, statusLogId: Long, file: MultipartFile, type: String): S3FileResponse {
        val (_, animal, statusLog) = validateUserAndStatusLog(username, animalId, statusLogId)

        val objectKey = s3Service.uploadFile(file, "animals/$animalId/status-logs/$statusLogId/documents")
        val document = documentRepository.save(Document().apply {
            this.type = type
            this.objectKey = objectKey
            this.documentName = file.originalFilename
            this.animal = animal
        })

        statusLogDocumentRepository.save(StatusLogDocument().apply {
            this.animalStatusLog = statusLog
            this.document = document
        })

        return S3FileResponse(objectKey, s3Service.generatePresignedUrl(objectKey))
    }
    @Transactional(readOnly = true)
    override fun getAnimalAttributesHistory(animalId: Long): List<AttributeHistoryResponse> {
        val animal = animalRepository.findById(animalId)
            .orElseThrow { EntityNotFoundException("Animal not found") }

        return attributeRepository.findByAnimalId(animalId)
            .flatMap { attribute ->
                attribute.valueHistories.map { history ->
                    AttributeHistoryResponse(
                        attributeName = attribute.name ?: "",
                        oldValue = history.value,
                        changedAt = history.recordedAt ?: LocalDate.now(),
                        changedBy = history.user.username ?: ""
                    )
                }
            }
    }

    @Transactional(readOnly = true)
    fun validateUserAndAnimal(username: String, animalId: Long): Pair<User, Animal> {
        val user = userRepository.findByUsername(username)
            ?: throw EntityNotFoundException("User not found")

        val animal = animalRepository.findById(animalId)
            .orElseThrow { EntityNotFoundException("Animal not found") }

        if (animal.animalUsers.none { it.user?.id == user.id }) {
            throw AccessDeniedException("User doesn't have access to this animal")
        }

        return user to animal
    }

    @Transactional(readOnly = true)
    fun validateUserAndStatusLog(username: String, animalId: Long, statusLogId: Long): Triple<User, Animal, AnimalStatusLog> {
        val (user, animal) = validateUserAndAnimal(username, animalId)

        val statusLog = statusLogRepository.findById(statusLogId)
            .orElseThrow { EntityNotFoundException("Status log not found") }

        if (statusLog.animal.id != animalId) {
            throw AccessDeniedException("Status log doesn't belong to this animal")
        }

        return Triple(user, animal, statusLog)
    }
    @Transactional(readOnly = true)
    override fun getUserAnimals(username: String): List<AnimalResponse> {
        val user = userRepository.findByUsername(username)
            ?: throw EntityNotFoundException("User not found")

        return user.animalUsers.mapNotNull { it.animal?.toDto() }
    }
    @Transactional(readOnly = true)
    override fun getAnimal(username: String, animalId: Long): AnimalResponse {
        val (_, animal) = validateUserAndAnimal(username, animalId)
        return animal.toDto()
    }
    @Transactional(readOnly = true)
    override fun getStatusLog(id: Long): StatusLogResponse {
        val log = statusLogRepository.findById(id)
            .orElseThrow { EntityNotFoundException("Status log not found") }
        return log.toDto()
    }
    @Transactional(readOnly = true)
    override fun getStatusLogs(username: String, animalId: Long): List<StatusLogResponse> {
        val (_, animal) = validateUserAndAnimal(username, animalId)
        return statusLogRepository.findByAnimalId(animalId).map { it.toDto() }
    }

    @Transactional
    override fun deleteAnimal(username: String, animalId: Long) {
        val (_, animal) = validateUserAndAnimal(username, animalId)

        animal.documents.forEach {
            it.objectKey?.let { key -> s3Service.deleteFile(key) }
            documentRepository.delete(it)
        }

        animal.animalPhotos.forEach {
            it.photo?.objectKey?.let { key -> s3Service.deleteFile(key) }
            it.photo?.let { photo -> photoRepository.delete(photo) }
        }

        animalRepository.delete(animal)
    }

    @Transactional
    override fun updateAnimal(username: String, animalId: Long, request: AnimalUpdateRequest): AnimalResponse {
        val (_, animal) = validateUserAndAnimal(username, animalId)

        request.name?.let { animal.name = it }
        request.description?.let { animal.description = it }
        request.birthDate?.let { animal.birthDate = it }
        request.mass?.let { animal.mass = it }

        return animalRepository.save(animal).toDto()
    }

    @Transactional
    override fun updateStatusLog(
        username: String,
        animalId: Long,
        statusLogId: Long,
        request: StatusLogUpdateRequest
    ): StatusLogResponse {
        val (_, _, statusLog) = validateUserAndStatusLog(username, animalId, statusLogId)

        request.notes?.let { statusLog.notes = it }
        request.logDate?.let { statusLog.logDate = it }

        return statusLogRepository.save(statusLog).toDto()
    }

    @Transactional
    override fun deleteStatusLog(username: String, animalId: Long, statusLogId: Long) {
        val (_, _, statusLog) = validateUserAndStatusLog(username, animalId, statusLogId)

        statusLog.statusLogPhotos.forEach {
            it.photo?.objectKey?.let { key -> s3Service.deleteFile(key) }
            it.photo?.let { photo -> photoRepository.delete(photo) }
        }

        statusLog.statusLogDocuments.forEach {
            it.document?.objectKey?.let { key -> s3Service.deleteFile(key) }
            it.document?.let { doc -> documentRepository.delete(doc) }
        }

        statusLogRepository.delete(statusLog)
    }

    @Transactional
    override fun updateAttribute(
        username: String,
        animalId: Long,
        attributeId: Short,
        request: AttributeUpdateRequest
    ): AttributeResponse {
        val (user, animal) = validateUserAndAnimal(username, animalId)
        val attribute = attributeRepository.findById(attributeId)
            .orElseThrow { EntityNotFoundException("Attribute not found") }

        if (attribute.animal?.id != animalId) {
            throw AccessDeniedException("Attribute doesn't belong to this animal")
        }

        request.name?.let { attribute.name = it }

        if (request.value != null) {
            val value = attribute.values.firstOrNull() ?: Value().apply {
                this.attribute = attribute
            }
            value.value = request.value
            attribute.values.clear()
            attribute.values.add(value)

            attributeValueHistoryRepository.save(AttributeValueHistory().apply {
                this.value = request.value
                this.recordedAt = LocalDate.now()
                this.user = user
                this.animal = animal
                this.attribute = attribute
            })
        }

        return attributeRepository.save(attribute).toDto()
    }

    @Transactional
    override fun addAttribute(
        username: String,
        animalId: Long,
        request: AttributeRequest
    ): AttributeResponse {
        val (_, animal) = validateUserAndAnimal(username, animalId)

        val attribute = Attribute().apply {
            name = request.name
            this.animal = animal
        }.also { attr ->
            attr.values.add(Value().apply {
                value = request.value
                attribute = attr
            })
        }

        return attributeRepository.save(attribute).toDto()
    }

    @Transactional
    override fun deleteAttribute(username: String, animalId: Long, attributeId: Short) {
        val (_, _) = validateUserAndAnimal(username, animalId)
        val attribute = attributeRepository.findById(attributeId)
            .orElseThrow { EntityNotFoundException("Attribute not found") }

        if (attribute.animal?.id != animalId) {
            throw AccessDeniedException("Attribute doesn't belong to this animal")
        }

        attributeRepository.delete(attribute)
    }

    @Transactional
    override fun deleteAnimalPhoto(username: String, photoId: Long) {
        val photo = photoRepository.findById(photoId)
            .orElseThrow { EntityNotFoundException("Photo not found") }

        val animalPhoto = animalPhotoRepository.findByPhotoId(photoId)
            ?: throw AccessDeniedException("Photo not linked to animal")

        validateUserAndAnimal(username, animalPhoto.animal?.id ?: throw IllegalStateException())

        photo.objectKey?.let { s3Service.deleteFile(it) }
        photoRepository.delete(photo)
    }

    @Transactional
    override fun deleteAnimalDocument(username: String, documentId: Long) {
        val document = documentRepository.findById(documentId)
            .orElseThrow { EntityNotFoundException("Document not found") }

        validateUserAndAnimal(username, document.animal?.id ?: throw IllegalStateException())

        document.objectKey?.let { s3Service.deleteFile(it) }
        documentRepository.delete(document)
    }
    @Transactional(readOnly = true)
    override fun getAnimalAnalytics(animalId: Long): List<AnimalAnalyticsResponse> {
        val attributes = attributeRepository.findByAnimalId(animalId)

        return attributes.map { attribute ->
            val histories = attribute.valueHistories
                .sortedBy { it.recordedAt }
                .map { history ->
                    AttributeChange(
                        date = history.recordedAt ?: LocalDate.now(),
                        value = history.value ?: "",
                        changedBy = history.user.username ?: ""
                    )
                }

            val numericValues = histories
                .mapNotNull { it.value.toDoubleOrNull() }

            val stats = if (numericValues.isNotEmpty()) {
                AttributeStats(
                    minValue = numericValues.min().toString(),
                    maxValue = numericValues.max().toString(),
                    avgValue = numericValues.average()
                )
            } else {
                null
            }

            AnimalAnalyticsResponse(
                attributeName = attribute.name ?: "Unknown",
                changes = histories,
                stats = stats
            )
        }
    }
}
```

=== Файл: service/interfaces/UserService.kt ===
```kotlin
package ru.animaltracker.userservice.service.interfaces

import org.springframework.web.multipart.MultipartFile
import ru.animaltracker.userservice.dto.S3FileResponse
import ru.animaltracker.userservice.dto.UserResponse
import ru.animaltracker.userservice.dto.UserUpdateRequest

interface UserService {
    fun updateUser(username: String, request: UserUpdateRequest): UserResponse
    fun getUser(username: String): UserResponse
     fun uploadUserPhoto(username: String, file: MultipartFile): S3FileResponse
}
```

=== Файл: service/interfaces/AnimalService.kt ===
```kotlin
package ru.animaltracker.userservice.service.interfaces

import org.springframework.web.multipart.MultipartFile
import ru.animaltracker.userservice.dto.*

interface AnimalService {
    fun createAnimal(username: String, request: AnimalCreateRequest): AnimalResponse
     fun  addAnimalPhoto(username: String, animalId: Long, file: MultipartFile): S3FileResponse
     fun addAnimalDocument(username: String, animalId: Long, file: MultipartFile, type: String): S3FileResponse
     fun addStatusLog(username: String, animalId: Long, request: StatusLogCreateRequest): StatusLogResponse
     fun addStatusLogPhoto(username: String, animalId: Long, statusLogId: Long, file: MultipartFile): S3FileResponse
     fun addStatusLogDocument(username: String, animalId: Long, statusLogId: Long, file: MultipartFile, type: String): S3FileResponse
     fun getAnimalAttributesHistory(animalId: Long): List<AttributeHistoryResponse>
     fun getUserAnimals(username: String): List<AnimalResponse>
     fun getAnimal(username: String, animalId: Long): AnimalResponse
     fun getStatusLogs(username: String, animalId: Long): List<StatusLogResponse>
     fun deleteAnimal(username: String, animalId: Long)
     fun updateAnimal(username: String, animalId: Long, request: AnimalUpdateRequest): AnimalResponse
     fun updateStatusLog(username: String, animalId: Long, statusLogId: Long, request: StatusLogUpdateRequest): StatusLogResponse
     fun deleteStatusLog(username: String, animalId: Long, statusLogId: Long)
     fun updateAttribute(username: String, animalId: Long, attributeId: Short, request: AttributeUpdateRequest): AttributeResponse
     fun addAttribute(username: String, animalId: Long, request: AttributeRequest): AttributeResponse
     fun deleteAttribute(username: String, animalId: Long, attributeId: Short)
     fun deleteAnimalPhoto(username: String, photoId: Long)
     fun deleteAnimalDocument(username: String, documentId: Long)
     fun getAnimalAnalytics(animalId: Long): List<AnimalAnalyticsResponse>
     fun exportAnimalToPdf(username: String, animalId: Long): ByteArray
     fun getStatusLog(id: Long): StatusLogResponse
}

```

=== Файл: service/interfaces/S3Service.kt ===
```kotlin
package ru.animaltracker.userservice.service.interfaces

import org.springframework.web.multipart.MultipartFile
import java.time.Duration

interface S3Service {
     fun uploadFile(
        file: MultipartFile,
        prefix: String,
        metadata: Map<String, String> = emptyMap()
    ): String

     fun generatePresignedUrl(objectKey: String, duration: Duration): String
     fun generatePresignedUrl(objectKey: String): String
     fun deleteFile(objectKey: String)
     fun getFileMetadata(objectKey: String): Map<String, String>
}
```

=== Файл: exception/Exceptions.kt ===
```kotlin
package ru.animaltracker.userservice.exception

class FileUploadException(message: String) : RuntimeException(message)
class FileProcessingException(message: String) : RuntimeException(message)
```

=== Файл: entity/Photo.kt ===
```kotlin
package ru.animaltracker.userservice.entity

import jakarta.persistence.*
import org.springframework.data.annotation.CreatedDate
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import java.time.LocalDateTime
import jakarta.persistence.*
import java.time.LocalDate
@Entity
@Table(name = "photo")
class Photo {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0

    @Column(name = "object_key", length = 512, unique = true)
    var objectKey: String? = null

    @Column(name = "created_at")
    var createdAt: LocalDate? = null

    @OneToMany(mappedBy = "photo", cascade = [CascadeType.ALL], orphanRemoval = true)
    var userPhotos: MutableSet<UserPhoto> = mutableSetOf()

    @OneToMany(mappedBy = "photo", cascade = [CascadeType.ALL], orphanRemoval = true)
    var animalPhotos: MutableSet<AnimalPhoto> = mutableSetOf()

    @OneToMany(mappedBy = "photo", cascade = [CascadeType.ALL], orphanRemoval = true)
    var statusLogPhotos: MutableSet<StatusLogPhoto> = mutableSetOf()

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Photo) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()

    override fun toString(): String = "Photo(id=$id)"
}
```

=== Файл: entity/AnimalStatusLog.kt ===
```kotlin
package ru.animaltracker.userservice.entity
import jakarta.persistence.*
import ru.animaltracker.userservice.dto.StatusLogResponse
import java.time.LocalDate
@Entity
@Table(name = "animal_status_log")
class AnimalStatusLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0

    @Column(name = "log_date")
    var logDate: LocalDate? = null

    @Column(columnDefinition = "text")
    var notes: String? = null

    @Column(name = "updated_at")
    var updatedAt: LocalDate? = null

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "animal_id")
    lateinit var animal: Animal

    @OneToMany(mappedBy = "animalStatusLog", cascade = [CascadeType.ALL], orphanRemoval = true)
    var statusLogPhotos: MutableSet<StatusLogPhoto> = mutableSetOf()

    @OneToMany(mappedBy = "animalStatusLog", cascade = [CascadeType.ALL], orphanRemoval = true)
    var statusLogDocuments: MutableSet<StatusLogDocument> = mutableSetOf()

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "user_id")
    lateinit var user: User

    constructor()

    constructor(notes: String?, logDate: LocalDate?, animal: Animal, user: User) : this() {
        this.notes = notes
        this.logDate = logDate
        this.animal = animal
        this.user = user
        this.updatedAt = LocalDate.now()
    }

    fun addPhoto(photo: Photo): StatusLogPhoto {
        val statusLogPhoto = StatusLogPhoto().apply {
            this.animalStatusLog = this@AnimalStatusLog
            this.photo = photo
        }
        statusLogPhotos.add(statusLogPhoto)
        return statusLogPhoto
    }

    fun addDocument(document: Document): StatusLogDocument {
        val statusLogDocument = StatusLogDocument().apply {
            this.animalStatusLog = this@AnimalStatusLog
            this.document = document
        }
        statusLogDocuments.add(statusLogDocument)
        return statusLogDocument
    }

    fun toDto(): StatusLogResponse {
        return StatusLogResponse(
            id = id,
            logDate = logDate ?: LocalDate.now(),
            notes = notes,
            photos = statusLogPhotos.mapNotNull { it.photo?.objectKey },
            documents = statusLogDocuments.mapNotNull { it.document?.objectKey }
        )
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is AnimalStatusLog) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()

    override fun toString(): String = "AnimalStatusLog(id=$id)"
}
```

=== Файл: entity/AnimalPhoto.kt ===
```kotlin
package ru.animaltracker.userservice.entity
import jakarta.persistence.*
import java.time.LocalDate

@Entity
@Table(name = "animal_photo")
class AnimalPhoto {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "animal_id")
    var animal: Animal? = null

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "photo_id")
    var photo: Photo? = null

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is AnimalPhoto) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()

    override fun toString(): String = "AnimalPhoto(id=$id)"
}
```

=== Файл: entity/User.kt ===
```kotlin
package ru.animaltracker.userservice.entity

import jakarta.persistence.*
import ru.animaltracker.userservice.dto.UserResponse
import java.time.LocalDate

@Entity
@Table(name = "users")
class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0

    @Column(length = 255)
    var email: String? = null

    @Column(length = 255)
    var username: String? = null

    @Column(name = "first_name", length = 255)
    var firstName: String? = null

    @Column(name = "last_name", length = 255)
    var lastName: String? = null

    @Column(length = 255)
    var city: String? = null

    @Column(name = "about_me", length = 255)
    var aboutMe: String? = null

    @OneToMany(mappedBy = "user", cascade = [CascadeType.ALL], orphanRemoval = true)
    var userPhotos: MutableSet<UserPhoto> = mutableSetOf()

    @OneToMany(mappedBy = "user", cascade = [CascadeType.ALL], orphanRemoval = true)
    var animalUsers: MutableSet<AnimalUser> = mutableSetOf()

    @OneToMany(mappedBy = "user", cascade = [CascadeType.ALL], orphanRemoval = true)
    var attributeValueHistories: MutableSet<AttributeValueHistory> = mutableSetOf()

    fun addAnimal(animal: Animal) {
        val animalUser = AnimalUser().apply {
            this.user = this@User
            this.animal = animal
        }
        animalUsers.add(animalUser)
        animal.animalUsers.add(animalUser)
    }

    fun getAnimals(): List<Animal> = animalUsers.mapNotNull { it.animal }

    fun toDto(): UserResponse {
        return UserResponse(
            username = username ?: "",
            firstName = firstName,
            lastName = lastName,
            city = city,
            aboutMe = aboutMe,
            photoUrl = userPhotos.firstOrNull()?.photo?.objectKey
        )
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is User) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()

    override fun toString(): String = "User(id=$id, username=$username)"
}
```

=== Файл: entity/StatusLogPhoto.kt ===
```kotlin
package ru.animaltracker.userservice.entity
import jakarta.persistence.*
import java.time.LocalDate
@Entity
@Table(name = "status_log_photo")
class StatusLogPhoto {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "photo_id")
    var photo: Photo? = null

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "animal_status_log_id")
    var animalStatusLog: AnimalStatusLog? = null

    constructor()

    constructor(statusLog: AnimalStatusLog, photo: Photo) : this() {
        this.animalStatusLog = statusLog
        this.photo = photo
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is StatusLogPhoto) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()

    override fun toString(): String = "StatusLogPhoto(id=$id)"
}
```

=== Файл: entity/StatusLogDocument.kt ===
```kotlin
package ru.animaltracker.userservice.entity
import jakarta.persistence.*
import java.time.LocalDate
@Entity
@Table(name = "status_log_document")
class StatusLogDocument {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "document_id")
    var document: Document? = null

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "animal_status_log_id")
    var animalStatusLog: AnimalStatusLog? = null

    constructor()

    constructor(statusLog: AnimalStatusLog, document: Document) : this() {
        this.animalStatusLog = statusLog
        this.document = document
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is StatusLogDocument) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()

    override fun toString(): String = "StatusLogDocument(id=$id)"
}
```

=== Файл: entity/Attribute.kt ===
```kotlin
package ru.animaltracker.userservice.entity
import jakarta.persistence.*
import ru.animaltracker.userservice.dto.AttributeResponse
import java.time.LocalDate

@Entity
@Table(name = "attribute")
class Attribute {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Short = 0

    @Column(length = 255)
    var name: String? = null

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "animal_id")
    var animal: Animal? = null

    @OneToMany(mappedBy = "attribute", cascade = [CascadeType.ALL], orphanRemoval = true)
    var values: MutableSet<Value> = mutableSetOf()

    @OneToMany(mappedBy = "attribute")
    var valueHistories: MutableSet<AttributeValueHistory> = mutableSetOf()

    fun addValue(valueStr: String) {
        val value = Value().apply {
            this.value = valueStr
            this.attribute = this@Attribute
        }
        values.add(value)
    }

    fun addHistory(history: AttributeValueHistory) {
        history.attribute = this
        valueHistories.add(history)
    }

    fun toDto(): AttributeResponse {
        return AttributeResponse(
            id = id,
            name = name,
            value = values.firstOrNull()?.value
        )
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Attribute) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()

    override fun toString(): String = "Attribute(id=$id)"
}
```

=== Файл: entity/UserPhoto.kt ===
```kotlin
package ru.animaltracker.userservice.entity
import jakarta.persistence.*
import java.time.LocalDate
@Entity
@Table(name = "user_photo")
class UserPhoto {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "user_id")
    lateinit var user: User

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "photo_id")
    var photo: Photo? = null

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is UserPhoto) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()

    override fun toString(): String = "UserPhoto(id=$id)"
}
```

=== Файл: entity/Value.kt ===
```kotlin
package ru.animaltracker.userservice.entity
import jakarta.persistence.*
import java.time.LocalDate

@Entity
@Table(name = "value")
class Value{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0

    @Column(length = 1024)
    var value: String? = null

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "attribute_id")
    var attribute: Attribute? = null

override fun equals(other: Any?): Boolean {
    if (this === other) return true
    if (other !is Value) return false
    return id == other.id
}

override fun hashCode(): Int = id.hashCode()

override fun toString(): String = "Value(id=$id, value=$value)"
}
```

=== Файл: entity/AnimalUser.kt ===
```kotlin
package ru.animaltracker.userservice.entity
import jakarta.persistence.*
import java.time.LocalDate
@Entity
@Table(name = "animal_user")
class AnimalUser {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    var user: User? = null

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "animal_id")
    var animal: Animal? = null

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is AnimalUser) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()

    override fun toString(): String = "AnimalUser(id=$id)"
}
```

=== Файл: entity/Animal.kt ===
```kotlin
package ru.animaltracker.userservice.entity

import jakarta.persistence.*
import ru.animaltracker.userservice.dto.AnimalResponse
import java.math.BigDecimal
import java.time.LocalDate

@Entity
@Table(name = "animal")
class Animal {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0

    @Column(name = "body_mass")
    var mass: BigDecimal? = null

    @Column(name = "birth_date")
    var birthDate: LocalDate? = null

    @Column(name = "created_at")
    var createdAt: LocalDate? = null

    @Column(length = 255)
    var name: String? = null

    @Column(columnDefinition = "text")
    var description: String? = null

    @OneToMany(mappedBy = "animal", cascade = [CascadeType.ALL], orphanRemoval = true)
    var attributes: MutableSet<Attribute> = mutableSetOf()

    @OneToMany(mappedBy = "animal", cascade = [CascadeType.ALL], orphanRemoval = true)
    var animalPhotos: MutableSet<AnimalPhoto> = mutableSetOf()

    @OneToMany(mappedBy = "animal", cascade = [CascadeType.ALL], orphanRemoval = true)
    var animalUsers: MutableSet<AnimalUser> = mutableSetOf()

    @OneToMany(mappedBy = "animal", cascade = [CascadeType.ALL], orphanRemoval = true)
    var documents: MutableSet<Document> = mutableSetOf()

    @OneToMany(mappedBy = "animal", cascade = [CascadeType.ALL], orphanRemoval = true)
    var statusLogs: MutableSet<AnimalStatusLog> = mutableSetOf()

    @OneToMany(mappedBy = "animal", cascade = [CascadeType.ALL], orphanRemoval = true)
    var attributeValueHistories: MutableSet<AttributeValueHistory> = mutableSetOf()

    fun addStatusLog(statusLog: AnimalStatusLog) {
        statusLogs.add(statusLog)
        statusLog.animal = this
    }

    fun addPhoto(photo: Photo): AnimalPhoto {
        val animalPhoto = AnimalPhoto().apply {
            this.animal = this@Animal
            this.photo = photo
        }
        animalPhotos.add(animalPhoto)
        photo.animalPhotos.add(animalPhoto)
        return animalPhoto
    }

    fun addDocument(document: Document) {
        documents.add(document)
        document.animal = this
    }

    fun toDto(): AnimalResponse {
        return AnimalResponse(
            id = id,
            name = name,
            description = description,
            birthDate = birthDate,
            mass = mass,
            attributes = attributes.map { it.toDto() },
            photos = animalPhotos.mapNotNull { it.photo?.objectKey }
        )
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Animal) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()

    override fun toString(): String = "Animal(id=$id, name=$name)"
}
```

=== Файл: entity/Document.kt ===
```kotlin
package ru.animaltracker.userservice.entity
import jakarta.persistence.*
import java.time.LocalDate
@Entity
@Table(name = "document")
class Document {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0

    @Column(length = 255)
    var type: String? = null

    @Column(name = "object_key", length = 512)
    var objectKey: String? = null

    @Column(name = "document_name", length = 255)
    var documentName: String? = null

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "animal_id")
    var animal: Animal? = null

    @OneToMany(mappedBy = "document", cascade = [CascadeType.ALL], orphanRemoval = true)
    var statusLogDocuments: MutableSet<StatusLogDocument> = mutableSetOf()

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is Document) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()

    override fun toString(): String = "Document(id=$id)"
}
```

=== Файл: entity/AttributeValueHistory.kt ===
```kotlin
package ru.animaltracker.userservice.entity
import jakarta.persistence.*
import java.time.LocalDate
@Entity
@Table(name = "attribute_value_history")
class AttributeValueHistory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0

    @Column(length = 1024)
    var value: String? = null

    @Column(name = "recorded_at")
    var recordedAt: LocalDate? = null

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "user_id")
    lateinit var user: User

    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "animal_id")
    lateinit var animal: Animal

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "attribute_id")
    var attribute: Attribute? = null

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is AttributeValueHistory) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()

    override fun toString(): String = "AttributeValueHistory(id=$id)"
}
```

=== Файл: dto/AttributeChange.kt ===
```kotlin
package ru.animaltracker.userservice.dto

import java.time.LocalDate

data class AttributeChange(
    val date: LocalDate,
    val value: String,
    val changedBy: String
)
```

=== Файл: dto/AttributeStats.kt ===
```kotlin
package ru.animaltracker.userservice.dto

data class AttributeStats(
    val minValue: String?,
    val maxValue: String?,
    val avgValue: Double?
)
```

=== Файл: dto/S3FileResponse.kt ===
```kotlin
package ru.animaltracker.userservice.dto

data class S3FileResponse(
    val objectKey: String,
    val presignedUrl: String
)
```

=== Файл: dto/StatusLogResponse.kt ===
```kotlin
package ru.animaltracker.userservice.dto

import java.time.LocalDate

data class StatusLogResponse(
    var id: Long = 0,
    var logDate: LocalDate = LocalDate.now(),
    var notes: String? = null,
    var photos: List<String> = emptyList(),
    var documents: List<String> = emptyList()
)
```

=== Файл: dto/AnimalResponse.kt ===
```kotlin
package ru.animaltracker.userservice.dto

import java.math.BigDecimal
import java.time.LocalDate

data class AnimalResponse(
    var id: Long = 0,
    var name: String? = null,
    var description: String? = null,
    var birthDate: LocalDate? = null,
    var mass: BigDecimal? = null,
    var attributes: List<AttributeResponse> = emptyList(),
    var photos: List<String> = emptyList()
)
```

=== Файл: dto/UserResponse.kt ===
```kotlin
package ru.animaltracker.userservice.dto

data class UserResponse(
    val username: String,
    val firstName: String?,
    val lastName: String?,
    val city: String?,
    val aboutMe: String?,
    var photoUrl: String?
)
```

=== Файл: dto/AttributeRequest.kt ===
```kotlin
package ru.animaltracker.userservice.dto

data class AttributeRequest(
    val name: String,
    val value: String
)
```

=== Файл: dto/AttributeHistoryResponse.kt ===
```kotlin
package ru.animaltracker.userservice.dto

import java.time.LocalDate

data class AttributeHistoryResponse(
    val attributeName: String,
    val oldValue: String?,
    val changedAt: LocalDate,
    val changedBy: String
)
```

=== Файл: dto/UserCreatedEvent.kt ===
```kotlin
package ru.animaltracker.userservice.dto

data class UserCreatedEvent(
    val email: String,
    val username: String
)
```

=== Файл: dto/AnimalUpdateRequest.kt ===
```kotlin
package ru.animaltracker.userservice.dto

import java.math.BigDecimal
import java.time.LocalDate

data class AnimalUpdateRequest(
    val name: String?,
    val description: String?,
    val birthDate: LocalDate?,
    val mass: BigDecimal?
)
```

=== Файл: dto/StatusLogUpdateRequest.kt ===
```kotlin
package ru.animaltracker.userservice.dto

import java.time.LocalDate

data class StatusLogUpdateRequest(
    val notes: String?,
    val logDate: LocalDate?
)
```

=== Файл: dto/StatusLogCreateRequest.kt ===
```kotlin
package ru.animaltracker.userservice.dto

import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.PastOrPresent
import java.time.LocalDate

data class StatusLogCreateRequest(
    @field:NotBlank
    val notes: String?,

    val logDate: LocalDate?
)
```

=== Файл: dto/UserUpdateRequest.kt ===
```kotlin
package ru.animaltracker.userservice.dto

import jakarta.validation.constraints.Size

data class UserUpdateRequest(
    @field:Size(max = 255)
    val firstName: String?,

    @field:Size(max = 255)
    val lastName: String?,

    @field:Size(max = 255)
    val city: String?,

    @field:Size(max = 255)
    val aboutMe: String?
)

```

=== Файл: dto/AnimalCreateRequest.kt ===
```kotlin
package ru.animaltracker.userservice.dto

import java.math.BigDecimal
import java.time.LocalDate

data class AnimalCreateRequest(
    val name: String,
    val description: String?,
    val birthDate: LocalDate?,
    val mass: BigDecimal?,
    val attributes: List<AttributeRequest>
)
```

=== Файл: dto/AnimalAnalyticsResponse.kt ===
```kotlin
package ru.animaltracker.userservice.dto

data class AnimalAnalyticsResponse(
    val attributeName: String,
    val changes: List<AttributeChange>,
    val stats: AttributeStats?
)
```

=== Файл: dto/AttributeResponse.kt ===
```kotlin
package ru.animaltracker.userservice.dto

data class AttributeResponse(
    var id: Short = 0,
    var name: String? = null,
    var value: String? = null
)
```

=== Файл: dto/AttributeUpdateRequest.kt ===
```kotlin
package ru.animaltracker.userservice.dto

data class AttributeUpdateRequest(
    val name: String?,
    val value: String?
)
```

=== Файл: config/KafkaConsumerConfig.kt ===
```kotlin
package ru.animaltracker.userservice.config

import org.apache.kafka.clients.consumer.ConsumerConfig
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory
import org.springframework.kafka.core.ConsumerFactory
import org.springframework.kafka.core.DefaultKafkaConsumerFactory

@Configuration
class KafkaConsumerConfig {

    @Bean
    fun consumerFactory(): ConsumerFactory<String, String> {
        val configProps = mapOf(
            ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG to "kafka:9092",
            ConsumerConfig.GROUP_ID_CONFIG to "db-event",
            ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG to "org.apache.kafka.common.serialization.StringDeserializer",
            ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG to "org.apache.kafka.common.serialization.StringDeserializer"
        )
        return DefaultKafkaConsumerFactory(configProps)
    }

    @Bean
    fun kafkaListenerContainerFactory(): ConcurrentKafkaListenerContainerFactory<String, String> {
        val factory = ConcurrentKafkaListenerContainerFactory<String, String>()
        factory.consumerFactory = consumerFactory()
        return factory
    }
}
```

=== Файл: config/GlobalExceptionHandler.kt ===
```kotlin
package ru.animaltracker.userservice.config

import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import ru.animaltracker.userservice.exception.FileProcessingException
import ru.animaltracker.userservice.exception.FileUploadException

@RestControllerAdvice
class GlobalExceptionHandler {

    @ExceptionHandler(FileUploadException::class)
    fun handleFileUploadException(ex: FileUploadException): ResponseEntity<Map<String, String>> {
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body(mapOf("error" to ex.message!!))
    }

    @ExceptionHandler(FileProcessingException::class)
    fun handleFileProcessingException(ex: FileProcessingException): ResponseEntity<Map<String, String>> {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(mapOf("error" to ex.message!!))
    }
}
```

=== Файл: config/S3ClientConfig.kt ===
```kotlin
package ru.animaltracker.userservice.config

import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import software.amazon.awssdk.auth.credentials.AwsBasicCredentials
import software.amazon.awssdk.auth.credentials.StaticCredentialsProvider
import software.amazon.awssdk.regions.Region
import software.amazon.awssdk.services.s3.S3AsyncClient
import software.amazon.awssdk.services.s3.S3Client
import software.amazon.awssdk.services.s3.presigner.S3Presigner
import java.net.URI

@Configuration
class S3ClientConfig(
    @Value("\${s3.region}") val region: String,
    @Value("\${s3.s3Url}") val s3Url: String,
    @Value("\${s3.accessKeyId}") val accessKeyId: String,
    @Value("\${s3.secretAccessKey}") val secretAccessKey: String
) {
    @Bean
    fun s3Client(): S3Client {
        val credentials = AwsBasicCredentials.create(accessKeyId, secretAccessKey)

        return S3Client.builder()
            .apply {
                if (s3Url.isNotEmpty()) {
                    endpointOverride(URI.create(s3Url))
                    forcePathStyle(true)
                }
            }
            .credentialsProvider(StaticCredentialsProvider.create(credentials))
            .region(Region.of(region))
            .build()
    }

    @Bean
    fun s3Presigner(): S3Presigner {
        val credentials = AwsBasicCredentials.create(accessKeyId, secretAccessKey)

        return S3Presigner.builder()
            .apply {
                if (s3Url.isNotEmpty()) {
                    endpointOverride(URI.create(s3Url))
                }
            }
            .credentialsProvider(StaticCredentialsProvider.create(credentials))
            .region(Region.of(region))
            .build()
    }
}
```

=== Файл: config/WebConfig.kt ===
```kotlin
package ru.animaltracker.userservice.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.client.RestTemplate
import org.springframework.web.servlet.config.annotation.CorsRegistry
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer

@Configuration
class WebConfig {

    @Bean
    fun restTemplate(): RestTemplate = RestTemplate()

    @Bean
    fun corsConfigurer(): WebMvcConfigurer {
        return object : WebMvcConfigurer {
            override fun addCorsMappings(registry: CorsRegistry) {
                registry.addMapping("/**")
                    .allowedOrigins("*")
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH")
                    .allowedHeaders("*")
            }
        }
    }
}
```

=== Файл: repository/AnimalStatusLogRepository.kt ===
```kotlin
package ru.animaltracker.userservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.userservice.entity.AnimalStatusLog

interface AnimalStatusLogRepository : JpaRepository<AnimalStatusLog, Long>{
    fun findByAnimalId(animalId: Long): List<AnimalStatusLog>
}
```

=== Файл: repository/AttributeRepository.kt ===
```kotlin
package ru.animaltracker.userservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.userservice.entity.Attribute

interface AttributeRepository : JpaRepository<Attribute, Short> {
    fun findByAnimalId(animalId: Long): List<Attribute>
}
```

=== Файл: repository/StatusLogDocumentRepository.kt ===
```kotlin
package ru.animaltracker.userservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.userservice.entity.StatusLogDocument

interface StatusLogDocumentRepository: JpaRepository<StatusLogDocument, Long> {
}
```

=== Файл: repository/PhotoRepository.kt ===
```kotlin
package ru.animaltracker.userservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.userservice.entity.Photo

interface PhotoRepository : JpaRepository<Photo, Long>
```

=== Файл: repository/UserRepository.kt ===
```kotlin
package ru.animaltracker.userservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.userservice.entity.User

interface UserRepository : JpaRepository<User, Long> {
    fun findByEmail(email: String): User?
    fun findByUsername(username: String): User?
}
```

=== Файл: repository/UserPhotoRepository.kt ===
```kotlin
package ru.animaltracker.userservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.userservice.entity.User
import ru.animaltracker.userservice.entity.UserPhoto

interface UserPhotoRepository : JpaRepository<UserPhoto, Long> {
    fun deleteAllByUser(user: User)
}
```

=== Файл: repository/DocumentRepository.kt ===
```kotlin
package ru.animaltracker.userservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.userservice.entity.Document

interface DocumentRepository : JpaRepository<Document, Long>
```

=== Файл: repository/AnimalPhotoRepository.kt ===
```kotlin
package ru.animaltracker.userservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.userservice.entity.AnimalPhoto

interface AnimalPhotoRepository : JpaRepository<AnimalPhoto, Long>{
    fun findByPhotoId(photoId: Long): AnimalPhoto?
}
```

=== Файл: repository/AnimalRepository.kt ===
```kotlin
package ru.animaltracker.userservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.userservice.entity.Animal

interface AnimalRepository : JpaRepository<Animal, Long>
```

=== Файл: repository/StatusLogPhotoRepository.kt ===
```kotlin
package ru.animaltracker.userservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.userservice.entity.StatusLogPhoto

interface StatusLogPhotoRepository: JpaRepository<StatusLogPhoto, Long> {
}
```

=== Файл: repository/AttributeValueHistoryRepository.kt ===
```kotlin
package ru.animaltracker.userservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.userservice.entity.AttributeValueHistory

interface AttributeValueHistoryRepository: JpaRepository<AttributeValueHistory, Long> {
}
```

Система авторизации (интеерсует только регистрация, атворизация, активация аккаунта) восстановление пароля и прочее игнорируется
=== Файл: AuthServiceApplication.kt ===
```kotlin
package ru.animaltracker.authservice

import org.springframework.boot.CommandLineRunner
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.boot.runApplication
import org.springframework.context.annotation.Bean
import org.springframework.data.jpa.repository.config.EnableJpaAuditing
import org.springframework.scheduling.annotation.EnableAsync
import ru.animaltracker.authservice.config.EmailConfig
import ru.animaltracker.authservice.config.JwtConfig
import ru.animaltracker.authservice.config.KafkaConfigProps
import ru.animaltracker.authservice.entity.Role
import ru.animaltracker.authservice.repository.RoleRepository

@EnableJpaAuditing
@EnableAsync
@SpringBootApplication
@EnableConfigurationProperties(ru.animaltracker.authservice.config.JwtConfig::class, EmailConfig::class, KafkaConfigProps::class)
class AuthServiceApplication{
    @Bean
    fun runner(roleRepository: RoleRepository): CommandLineRunner {
        return CommandLineRunner {
            if (roleRepository.findByName("USER") == null) {
                roleRepository.save(Role(name = "USER"))
            }
        }
    }
}

fun main(args: Array<String>) {
    runApplication<AuthServiceApplication>(*args)
}
```

=== Файл: controller/ActivationController.kt ===
```kotlin
package ru.animaltracker.authservice.controller

import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import ru.animaltracker.authservice.service.interfaces.ActivationService

@Tag(
    name = "Активация аккаунта при регистрации",
    description = "Эндпоинт для отправки кода подтверждения для активации аккаунта")
@RequestMapping("/api/auth/activate-account")
@RestController
class ActivationController(
    private val activationService: ActivationService
) {
    @Operation(
        summary = "Активация аккаунта",
        description = "Запрос на активацию аккаунта (прикладывание кода из почты)")
    @GetMapping
    fun confirm(
        @RequestParam token: String,
    ): ResponseEntity<String> {
        activationService.activateAccount(token)
        return ResponseEntity.ok("Account activated successfully")
    }

}
```

=== Файл: controller/LogoutController.kt ===
```kotlin
package ru.animaltracker.authservice.controller

import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.springframework.http.ResponseEntity
import org.springframework.security.core.Authentication
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import ru.animaltracker.authservice.service.LogoutService
@Tag(
    name = "Выход пользователя",
    description = "Обработка выхода пользователя")
@RequestMapping("/api/auth/logout")
@RestController
class LogoutController(
    private val logoutService: LogoutService
) {
    @Operation(
        summary = "Выход авторизированного пользователя",
        description = "Выход пользователя, с invoke его refresh токена и удалением cookie"
    )
    @PostMapping()
    fun logout(
        request: HttpServletRequest,
        response: HttpServletResponse,
        authentication: Authentication?
    ): ResponseEntity<String> {
        logoutService.logout(request, response, authentication)
        return ResponseEntity.ok("Logged out successfully")
    }
}
```

=== Файл: controller/TokenController.kt ===
```kotlin
package ru.animaltracker.authservice.controller

import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.servlet.http.HttpServletResponse
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.CookieValue
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import ru.animaltracker.authservice.dto.AuthResponseDTO
import ru.animaltracker.authservice.service.interfaces.TokenService

@Tag(
    name = "Токен",
    description = "Рефреш токена")
@RequestMapping("/api/auth/token")
@RestController
class TokenController(
    private val tokenService: TokenService
) {
    @Operation(
        summary = "Обновление токена",
        description = "Рефреш токенов пользователя, рефреш берется из cookie"
    )
    @PostMapping("/refresh")
    fun refreshToken(
        @CookieValue("REFRESH_TOKEN") refreshToken: String,
        response: HttpServletResponse
    ): ResponseEntity<AuthResponseDTO> {
        val newTokens = tokenService.refreshToken(refreshToken, response)
        return ResponseEntity.ok(newTokens)
    }
}
```

=== Файл: controller/PasswordController.kt ===
```kotlin
package ru.animaltracker.authservice.controller

import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.validation.Valid
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import ru.animaltracker.authservice.dto.PasswordRecoveryRequestDTO
import ru.animaltracker.authservice.dto.PasswordResetRequestDTO
import ru.animaltracker.authservice.service.impl.PasswordRecoveryServiceImpl

@Tag(
    name = "Восстановление пароля",
    description = "Все что касается восстановления аккаунта")
@RequestMapping("/api/auth/password")
@RestController
class PasswordController(
    private val passwordRecoveryService: PasswordRecoveryServiceImpl
) {
    @Operation(
        summary = "Запрос на восстановление пароля по почте",
        description = "После отправки запроса на почту отправляется код подтверждения"
    )
    @PostMapping("/recovery")
    fun sendPasswordRecoveryEmail(
        @RequestBody request: PasswordRecoveryRequestDTO
    ): ResponseEntity<String> {
        passwordRecoveryService.initiatePasswordRecovery(request.identifier)
        return ResponseEntity.ok("Password recovery email sent")
    }

    @Operation(
        summary = "Сброс пароля",
        description = "Сброс пароля по ранее полученному на почту коду сброса"
    )
    @PostMapping("/reset")
    fun resetPassword(
        @RequestBody @Valid request: PasswordResetRequestDTO
    ): ResponseEntity<String> {
        passwordRecoveryService.resetPassword(request.token, request.newPassword)
        return ResponseEntity.ok("Password has been reset successfully")
    }

}
```

=== Файл: controller/VkController.kt ===
```kotlin
package ru.animaltracker.authservice.controller

import io.swagger.v3.oas.annotations.Hidden
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import ru.animaltracker.authservice.dto.AuthResponseDTO
import ru.animaltracker.authservice.service.OAuthService

@Tag(
    name = "VK OAuth",
    description = "Все что касается обработки вк авторизации регистрации")
@RestController
@RequestMapping("/api/auth/login")
class VkController(
    private val oAuthService: OAuthService
){
    @Hidden
    @GetMapping("/oauth2/code/vk")
    fun handleRedirect(
        @RequestParam("code") code: String,
        response: HttpServletResponse
    ): AuthResponseDTO = oAuthService.authenticate(code, response)

    // Чисто открыть страничку VK авторизации
    @Operation(
        summary = "Открытие страницы авторизации VK",
        description = "Открывается VK страничка, после перенаправление и регистрация в системе или авторизация уже существующего"
    )
    @GetMapping("/vk")
    fun authorizeVK(request: HttpServletRequest): ResponseEntity<String>  = oAuthService.vkLoginPageOpen()
}
```

=== Файл: controller/AuthController.kt ===
```kotlin
package ru.animaltracker.authservice.controller

import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.tags.Tag
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import jakarta.validation.Valid
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.security.core.Authentication
import org.springframework.web.bind.annotation.*
import ru.animaltracker.authservice.dto.*
import ru.animaltracker.authservice.service.interfaces.AuthenticationService
import ru.animaltracker.authservice.service.LogoutService
import ru.animaltracker.authservice.service.interfaces.PasswordRecoveryService
import ru.animaltracker.authservice.service.interfaces.RegistrationService

@Tag(
    name = "Вход и Регистрация",
    description = "Обработка входа и регистрации пользователя")
@RestController
@RequestMapping("/api/auth")
class AuthController(
    private val registrationService: RegistrationService,
    private val authenticationService: AuthenticationService
) {

    @Operation(
        summary = "Регистрация",
        description = "Регистрация пользователя по почте юзернейму и паролю"
    )
    @PostMapping("/register")
    fun registerUser(@RequestBody @Valid registrationRequest: UserRequestDTO): ResponseEntity<UserResponseDTO> {
        val response = registrationService.register(registrationRequest)
        return ResponseEntity.status(HttpStatus.CREATED).body(response)
    }

    @Operation(
        summary = "Авторизация",
        description = "Авторизация пользователя, можно войти как по почте так и просто по юзернейму"
    )
    @PostMapping("/authenticate")
    fun authenticateUser(
        @RequestBody @Valid authRequest: AuthRequestDTO,
        response: HttpServletResponse
    ): ResponseEntity<AuthResponseDTO> {
        val authResponse = authenticationService.authenticate(authRequest, response)
        return ResponseEntity.ok(authResponse)
    }
}
```

=== Файл: enums/BusinessErrorCodes.kt ===
```kotlin
package ru.animaltracker.authservice.enums

import org.springframework.http.HttpStatus

enum class BusinessErrorCodes (
    val code: Int,
    val httpStatus: HttpStatus,
    val description: String
){
    NO_CODE(0, HttpStatus.NOT_IMPLEMENTED, "No code"),
    INCORRECT_CURRENT_PASSWORD(300, HttpStatus.BAD_REQUEST, "Incorrect password"),
    ACCOUNT_LOCKED(302, HttpStatus.FORBIDDEN, "User account is locked"),
    ACCOUNT_DISABLED(303, HttpStatus.FORBIDDEN, "User account is disabled"),
    BAD_CREDENTIALS(304, HttpStatus.UNAUTHORIZED, "Login and/or password is incorrect"),
    NEW_PASSWORD_DOES_NOT_MATCH(301, HttpStatus.BAD_REQUEST, "The new password does not match"),
    USER_ALREADY_EXISTS(305, HttpStatus.BAD_REQUEST, "User already exists"),
    INVALID_TOKEN(306, HttpStatus.UNAUTHORIZED, "Invalid token"),
    TOKEN_EXPIRED(307, HttpStatus.UNAUTHORIZED, "Token has expired"),
    USER_NOT_FOUND(308, HttpStatus.NOT_FOUND, "User not found")
}
```

=== Файл: enums/CookieName.kt ===
```kotlin
package ru.animaltracker.authservice.enums

enum class CookieName(
    private val cookieName: String,
) {
    ACCESS_TOKEN("access_token"),
    REFRESH_TOKEN("refresh_token"),
}
```

=== Файл: enums/Provider.kt ===
```kotlin
package ru.animaltracker.authservice.enums

enum class Provider {
    VK,
    PASSWORD,
}
```

=== Файл: enums/UserRole.kt ===
```kotlin
package ru.animaltracker.authservice.enums

enum class UserRole {
    ADMIN,
    USER,
}
```

=== Файл: enums/MailTokenType.kt ===
```kotlin
package ru.animaltracker.authservice.enums

enum class MailTokenType{
    CONFIRM,
    RECOVERY
}
```

=== Файл: enums/EmailTemplateName.kt ===
```kotlin
package ru.animaltracker.authservice.enums

enum class EmailTemplateName(
    val templateName: String
) {
    ACTIVATE_ACCOUNT("activate_account"),
    RECOVERY_PASSWORD("recovery_password")
}
```

=== Файл: enums/TokenType.kt ===
```kotlin
package ru.animaltracker.authservice.enums

enum class TokenType {
    ACCESS,
    REFRESH,
}
```

=== Файл: service/MessageProducerService.kt ===
```kotlin
package ru.animaltracker.authservice.service

import com.fasterxml.jackson.databind.ObjectMapper
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.stereotype.Service

@Service
class MessageProducerService(
    private val kafkaTemplate: KafkaTemplate<String, String>,
    private val objectMapper: ObjectMapper
) {

    fun sendMessage(topic: String, dto: Any) {
        val json = objectMapper.writeValueAsString(dto)
        kafkaTemplate.send(topic, json)
    }
}
```

=== Файл: service/PasswordRecoveryHelper.kt ===
```kotlin
package ru.animaltracker.authservice.service

import org.springframework.stereotype.Service
import ru.animaltracker.authservice.entity.MailToken
import ru.animaltracker.authservice.entity.User
import ru.animaltracker.authservice.enums.MailTokenType
import ru.animaltracker.authservice.repository.MailTokenRepository
import ru.animaltracker.authservice.config.EmailConfig
import ru.animaltracker.authservice.enums.EmailTemplateName
import ru.animaltracker.authservice.exception.GlobalExceptionHandler
import ru.animaltracker.authservice.service.interfaces.UserService
import java.security.SecureRandom
import java.time.LocalDateTime

@Service
class PasswordRecoveryHelper(
    private val mailTokenRepository: MailTokenRepository,
    private val userService: UserService,
    private val emailService: ru.animaltracker.authservice.service.EmailService,
    private val emailConfig: EmailConfig
) {

    fun generateAndSaveRecoveryToken(user: User): String {
        deactivateExistingTokens(user, MailTokenType.RECOVERY)

        val generatedToken = generateRecoveryCode()
        val mailToken = MailToken(
            token = generatedToken,
            createdAt = LocalDateTime.now(),
            expiresAt = LocalDateTime.now().plusSeconds(emailConfig.activationTokenExpiration),
            user = user,
            tokenType = MailTokenType.RECOVERY
        )
        mailTokenRepository.save(mailToken)
        return generatedToken
    }

    fun resetPassword(token: String, newPassword: String) {
        val mailToken = mailTokenRepository.findByToken(token)
            ?: throw GlobalExceptionHandler.InvalidTokenException("Invalid recovery token")

        if (LocalDateTime.now().isAfter(mailToken.expiresAt) || !mailToken.enabled) {
            throw GlobalExceptionHandler.InvalidTokenException("Recovery token expired or already used")
        }

        val user = mailToken.user
        userService.updatePassword(user, newPassword)
        mailToken.validatedAt = LocalDateTime.now()
        mailToken.enabled = false
        mailTokenRepository.save(mailToken)
    }

    fun sendRecoveryEmail(user: User, token: String) {
        emailService.sendEmail(
            to = user.email,
            username = user.username,
            emailTemplate = EmailTemplateName.RECOVERY_PASSWORD,
            confirmationUrl = emailConfig.activationUrl,
            activationCode = token,
            subject = "Password Recovery"
        )
    }

    private fun deactivateExistingTokens(user: User, tokenType: MailTokenType) {
        val activeTokens = mailTokenRepository.findByUserIdAndEnabledAndTokenType(
            userId = user.id!!,
            enabled = true,
            tokenType = tokenType
        )
        activeTokens.forEach { it.enabled = false }
        mailTokenRepository.saveAll(activeTokens)
    }

    private fun generateRecoveryCode(length: Int = 6): String {
        val secureRandom = SecureRandom()
        return (1..length)
            .map { secureRandom.nextInt(10) }
            .joinToString("")
    }
}
```

=== Файл: service/EmailService.kt ===
```kotlin
package ru.animaltracker.authservice.service

import jakarta.mail.internet.MimeMessage
import org.springframework.mail.javamail.JavaMailSender
import org.springframework.mail.javamail.MimeMessageHelper
import org.springframework.scheduling.annotation.Async
import org.springframework.stereotype.Service
import org.thymeleaf.context.Context
import org.thymeleaf.spring6.SpringTemplateEngine
import ru.animaltracker.authservice.config.EmailConfig
import ru.animaltracker.authservice.enums.EmailTemplateName

@Service
class EmailService(
    private val mailSender: JavaMailSender,
    private val templateEngine: SpringTemplateEngine,
    private val emailConfig: EmailConfig
) {
    @Async
    fun sendEmail(to: String,
                  username: String,
                  emailTemplate: EmailTemplateName,
                  confirmationUrl: String,
                  activationCode: String,
                  subject: String)
    {
        val mimeMessage: MimeMessage = mailSender.createMimeMessage()
        val helper = MimeMessageHelper(mimeMessage,
            MimeMessageHelper.MULTIPART_MODE_MIXED
            )
        val properties = mutableMapOf<String, Any>()
        properties["username"] = username
        properties["confirmationUrl"] = confirmationUrl
        properties["activation_code"] = activationCode

        val context = Context() // ThymeLeaf Context
        context.setVariables(properties)

        helper.setFrom(emailConfig.emailAddressSender)
        helper.setTo(to)
        helper.setSubject(subject)

        val template = templateEngine.process(emailTemplate.templateName, context)

        helper.setText(template, true)

        mailSender.send(mimeMessage)
    }
}
```

=== Файл: service/JwtService.kt ===
```kotlin
package ru.animaltracker.authservice.service

import io.jsonwebtoken.Claims
import io.jsonwebtoken.Jwts
import io.jsonwebtoken.io.Decoders
import io.jsonwebtoken.security.Keys
import jakarta.servlet.http.Cookie
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.stereotype.Service
import ru.animaltracker.authservice.config.JwtConfig
import ru.animaltracker.authservice.entity.User
import java.time.Instant
import java.time.LocalDateTime
import java.time.ZoneId
import java.util.*
import javax.crypto.SecretKey

@Service
class JwtService(private val jwtConfig: ru.animaltracker.authservice.config.JwtConfig) {

    fun getSignInKey(): SecretKey {
        val keyBytes = Decoders.BASE64.decode(jwtConfig.secretKey)
        return Keys.hmacShaKeyFor(keyBytes)
    }

    fun extractUsername(token: String): String? = extractClaim(token) { claims: Claims -> claims.subject }

    fun <T> extractClaim(token: String, claimsResolver: (Claims) -> T): T {
        val claims = extractAllClaims(token)
        return claimsResolver.invoke(claims)
    }

    fun extractAllClaims(token: String): Claims =
        Jwts.parser()
            .verifyWith(getSignInKey())
            .build()
            .parseSignedClaims(token)
            .payload

    private fun buildToken(
        extraClaims: Map<String, Any>,
        userDetails: UserDetails,
        jwtExpiration: Long
    ): String {
        val now = Instant.now()
        return Jwts.builder()
            .claims(extraClaims)
            .subject(userDetails.username)
            .issuedAt(Date.from(now))
            .expiration(Date.from(now.plusSeconds(jwtExpiration)))
            .signWith(getSignInKey())
            .compact()
    }

    fun isTokenValid(token: String, userDetails: UserDetails): Boolean {
        val username = extractUsername(token)
        return username != null &&
                username == userDetails.username &&
                !isTokenExpired(token)
    }

    fun createHttpOnlyCookie(name: String, value: String): Cookie {
        val cookie = Cookie(name, value)
        cookie.isHttpOnly = true
        cookie.maxAge = jwtConfig.expiration.toInt()
        cookie.path = "/"
        return cookie
    }

    private fun isTokenExpired(token: String): Boolean = extractExpiration(token).before(Date.from(Instant.now()))

    fun extractExpiration(token: String): Date = extractClaim(token, Claims::getExpiration)

    fun generateAccessToken(user: UserDetails): String {
        val userEntity = user as User
        val claims = mapOf<String, Any>(
            "roles" to user.authorities.map { it.authority },
            "token_type" to "ACCESS",
            "username" to userEntity.username,
            "user_id" to userEntity.id!!,
            "sub" to userEntity.username
        )
        return buildToken(claims, user, jwtConfig.expiration)
    }

    fun generateRefreshToken(user: UserDetails): String {
        val claims = mapOf("type" to "refresh")
        return buildToken(claims, user, jwtConfig.refreshExpiration)
    }
    fun isRefreshTokenValid(token: String): Boolean {
        val claims = extractAllClaims(token)
        return claims["type"] == "refresh" && !isTokenExpired(token)
    }

    /////////////////////////////////////////////
    fun extractExpirationLocalDateTime(token: String): LocalDateTime? {
        return try {
            val expirationDate = extractExpiration(token)
            expirationDate.toInstant()
                .atZone(ZoneId.systemDefault())
                .toLocalDateTime()
        } catch (e: Exception) {
            null
        }
    }
}
```

=== Файл: service/LogoutService.kt ===
```kotlin
package ru.animaltracker.authservice.service

import jakarta.servlet.http.Cookie
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.springframework.security.core.Authentication
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.web.authentication.logout.LogoutHandler
import org.springframework.stereotype.Service
import ru.animaltracker.authservice.enums.CookieName
import ru.animaltracker.authservice.repository.TokenRepository

@Service
class LogoutService(
    private val tokenRepository: TokenRepository
) : LogoutHandler {

    override fun logout(
        request: HttpServletRequest,
        response: HttpServletResponse,
        authentication: Authentication?
    ) {
        val refreshToken = getCookieValue(request, CookieName.REFRESH_TOKEN.name)

        if (refreshToken != null) {
            val storedToken = tokenRepository.findByToken(refreshToken)
            if (storedToken != null && !storedToken.revoked && !storedToken.expired) {
                storedToken.revoked = true
                storedToken.expired = true
                tokenRepository.save(storedToken)
            }
        }

        SecurityContextHolder.clearContext()

        clearCookie(response, CookieName.REFRESH_TOKEN.name)

        clearCookie(response, CookieName.ACCESS_TOKEN.name)
    }

    private fun getCookieValue(request: HttpServletRequest, name: String): String? {
        return request.cookies?.find { it.name == name }?.value
    }

    private fun clearCookie(response: HttpServletResponse, name: String) {
        val cookie = Cookie(name, null).apply {
            maxAge = 0
            path = "/"
            isHttpOnly = true
        }
        response.addCookie(cookie)
    }
}
```

=== Файл: service/OAuthService.kt ===
```kotlin
package ru.animaltracker.authservice.service

import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import org.springframework.stereotype.Service
import org.springframework.web.client.RestTemplate
import org.springframework.http.ResponseEntity
import org.springframework.http.HttpMethod
import jakarta.servlet.http.HttpServletResponse
import org.springframework.http.HttpStatus

import ru.animaltracker.authservice.config.VkApiConfig
import ru.animaltracker.authservice.dto.AuthResponseDTO
import ru.animaltracker.authservice.dto.UserRequestDTO
import ru.animaltracker.authservice.entity.User
import ru.animaltracker.authservice.enums.CookieName
import ru.animaltracker.authservice.enums.Provider

import ru.animaltracker.authservice.repository.UserRepository
import ru.animaltracker.authservice.service.interfaces.TokenService
import ru.animaltracker.authservice.service.interfaces.UserService
import java.net.URI
import java.time.LocalDateTime

@Service
class OAuthService(
    private val restTemplate: RestTemplate,
    private val userRepository: UserRepository,
    private val jwtService: ru.animaltracker.authservice.service.JwtService,
    private val userService: UserService,
    private val objectMapper: ObjectMapper,
    private val vkApiConfig: VkApiConfig,
    private val tokenService: TokenService
) {

    fun authenticate(code: String, response: HttpServletResponse): AuthResponseDTO {
        // Поменять код на токен
        val tokenResponse = exchangeCodeForAccessToken(code)
        val accessTokenVk = tokenResponse["access_token"].asText() // access вкшный

        val userId = tokenResponse["user_id"].asText()
        val email = tokenResponse["email"]?.asText()

        // размениваем на id
        val userInfoResponse = getUserInfoVk(accessTokenVk, userId)
        val vkId = userInfoResponse["response"][0]["id"].asLong()

        // Проверяем есть ли такой
        val existingUser = userRepository.findByVkId(vkId)
        val user = existingUser ?: createNewUser(vkId, email)

        val refreshToken: String = jwtService.generateRefreshToken(user)
        val accessToken: String = jwtService.generateAccessToken(user)

        // Кидаем в кукисы
        response.addCookie(jwtService.createHttpOnlyCookie(CookieName.ACCESS_TOKEN.name, accessToken))
        response.addCookie(jwtService.createHttpOnlyCookie(CookieName.REFRESH_TOKEN.name, refreshToken))

        // Пишем рефрешку
        tokenService.saveRefreshToken(user, refreshToken)

        return AuthResponseDTO(
            accessToken = accessToken,
            refreshToken = refreshToken,
            issuedAt = LocalDateTime.now(),
            accessExpiresAt = jwtService.extractExpirationLocalDateTime(accessToken),
            refreshExpiresAt = jwtService.extractExpirationLocalDateTime(refreshToken)
        )
    }

    private fun exchangeCodeForAccessToken(code: String): JsonNode {
        val tokenUri = vkApiConfig.provider.vk.tokenUri
        // Формировка ссылки
        val uri = URI.create(
            "$tokenUri?client_id=${vkApiConfig.registration.vk.clientId}" +
                    "&client_secret=${vkApiConfig.registration.vk.clientSecret}" +
                    "&redirect_uri=${vkApiConfig.registration.vk.redirectUri}" +
                    "&code=$code"
        )
        // Прокидываем GET
        val response: ResponseEntity<String> = restTemplate.exchange(
            uri,
            HttpMethod.GET,
            null,
            String::class.java
        )
        // Тело ответа
        return parseJson(response.body!!)
    }

    private fun getUserInfoVk(accessToken: String, userId: String): JsonNode {
        val userInfoUri = vkApiConfig.provider.vk.userInfoUri

        // Запрос на вытяжку инфы
        val uri = URI.create(
            "$userInfoUri?user_ids=$userId&fields=email&access_token=$accessToken&v=5.131"
        )

        val response: ResponseEntity<String> = restTemplate.exchange(
            uri,
            HttpMethod.GET,
            null,
            String::class.java
        )

        return parseJson(response.body!!)
    }

    private fun parseJson(json: String): JsonNode {
        return objectMapper.readTree(json)
    }

    private fun createNewUser(vkId: Long, email: String?): User {
        val userEmail = email ?: "${vkId}@vk.com"

        return userService.registerVkUser(
            UserRequestDTO(
                username = vkId.toString(),
                email = userEmail,
                password = null
            ),
            vkId
        )
    }
    fun vkLoginPageOpen(): ResponseEntity<String> {
        val uri = URI.create(
            "${vkApiConfig.provider.vk.authorizationUri}?" +
                    "client_id=${vkApiConfig.registration.vk.clientId}" +
                    "&client_secret=${vkApiConfig.registration.vk.clientSecret}" +
                    "&redirect_uri=${vkApiConfig.registration.vk.redirectUri}"
        )
        return ResponseEntity.status(HttpStatus.FOUND)
            .location(uri)
            .build()
    }
}
```

=== Файл: service/impl/UserServiceImpl.kt ===
```kotlin
package ru.animaltracker.authservice.service.impl

import jakarta.transaction.Transactional
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import ru.animaltracker.authservice.dto.UserRequestDTO
import ru.animaltracker.authservice.entity.Role
import ru.animaltracker.authservice.entity.User
import ru.animaltracker.authservice.enums.Provider
import ru.animaltracker.authservice.enums.UserRole
import ru.animaltracker.authservice.exception.GlobalExceptionHandler
import ru.animaltracker.authservice.repository.RoleRepository
import ru.animaltracker.authservice.repository.UserRepository
import ru.animaltracker.authservice.service.interfaces.UserService
import java.time.LocalDateTime

@Service
@Transactional
class UserServiceImpl(
    private val userRepository: UserRepository,
    private val roleRepository: RoleRepository,
    private val passwordEncoder: PasswordEncoder
): UserService {

    override fun saveUser(user: User): User = userRepository.save(user)

    override fun saveRole(role: Role): Role = roleRepository.save(role)

    override fun getUsers(): List<User> = userRepository.findAll()

    override fun registerUser(email: String, username: String, rawPassword: String): User {
        if (userRepository.findByEmail(email) != null) {
            throw GlobalExceptionHandler.UserAlreadyExistsException("Email already in use")
        }
        if (userRepository.findByUsername(username) != null) {
            throw GlobalExceptionHandler.UserAlreadyExistsException("Username already in use")
        }

        val userRole = roleRepository.findByName(UserRole.USER.toString())
            ?: throw IllegalStateException("Role USER not found")

        val user = User(
            email = email,
            username = username,
            password = passwordEncoder.encode(rawPassword),
            accountLocked = false,
            enabled = true, // TODO (ЭТО ДЛЯ ТЕСТОВ, ПОТОМ ПОМЕНЯТЬ)
            roles = mutableSetOf(userRole),
            vkId = null,
            provider = Provider.PASSWORD,
            createdAt = LocalDateTime.now(),
            updatedAt = LocalDateTime.now(),
        )
        return userRepository.save(user)
    }

    override fun registerVkUser(userRequest: UserRequestDTO, vkId: Long): User {
        if (userRepository.findByVkId(vkId) != null) {
            throw GlobalExceptionHandler.UserAlreadyExistsException("VK ID already exists INVALID_VK_ID")
        }

        val email = userRequest.email.ifEmpty { "${vkId}@vk.com" }

        val userRole = roleRepository.findByName(UserRole.USER.toString())
            ?: throw GlobalExceptionHandler.UserAlreadyExistsException("Role USER not found")

        val user = User(
            email = email,
            username = userRequest.username,
            provider = Provider.VK,
            enabled = true, // VK по умолчанию активированы
            accountLocked = false,
            roles = mutableSetOf(userRole),
            vkId = vkId,
            createdAt = LocalDateTime.now(),
            updatedAt = LocalDateTime.now(),
            password = null.toString()
        )
        userRepository.save(user)

        return user
    }

    override fun findByEmail(email: String): User? = userRepository.findByEmail(email)

    override fun findByUsername(username: String): User? = userRepository.findByUsername(username)

    override fun findById(id: Long): User? = userRepository.findById(id).orElse(null)

    override fun findByVkId(vkId: Long): User? = userRepository.findByVkId(vkId)

    override fun enableUser(user: User) {
        user.enabled = true
        userRepository.save(user)
    }

    override fun updatePassword(user: User, newPassword: String) {
        if (user.provider != Provider.PASSWORD) {
            throw IllegalStateException("VK User does not have a password")
        }
        user.password = passwordEncoder.encode(newPassword)
        userRepository.save(user)
    }
}
```

=== Файл: service/impl/AuthenticationServiceImpl.kt ===
```kotlin
package ru.animaltracker.authservice.service.impl

import jakarta.servlet.http.HttpServletResponse
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.userdetails.UsernameNotFoundException
import org.springframework.stereotype.Service
import ru.animaltracker.authservice.entity.User
import ru.animaltracker.authservice.config.JwtConfig
import ru.animaltracker.authservice.dto.AuthRequestDTO
import ru.animaltracker.authservice.dto.AuthResponseDTO
import ru.animaltracker.authservice.enums.CookieName
import ru.animaltracker.authservice.exception.GlobalExceptionHandler
import ru.animaltracker.authservice.service.interfaces.AuthenticationService
import ru.animaltracker.authservice.service.JwtService
import ru.animaltracker.authservice.service.interfaces.TokenService
import ru.animaltracker.authservice.service.interfaces.UserService
import java.time.LocalDateTime

@Service
class AuthenticationServiceImpl(
    private val authenticationManager: AuthenticationManager,
    private val userService: UserService,
    private val jwtService: ru.animaltracker.authservice.service.JwtService,
    private val tokenService: TokenService,
    private val jwtConfig: ru.animaltracker.authservice.config.JwtConfig
) : AuthenticationService {

    override fun authenticate(request: AuthRequestDTO, response: HttpServletResponse): AuthResponseDTO {

        val identifier: String = request.indentifier
        val userEntity: User = if (identifier.contains("@")) {
            userService.findByEmail(identifier)
        } else {
            userService.findByUsername(identifier)
        } ?: throw UsernameNotFoundException("User with identifier '$identifier' not found")

        val auth = authenticationManager.authenticate(
            UsernamePasswordAuthenticationToken(
                userEntity.username,
                request.password,
            )
        )
        val user = auth.principal as User

        val accessToken: String = jwtService.generateAccessToken(user)
        val refreshToken: String = jwtService.generateRefreshToken(user)

        response.addCookie(jwtService.createHttpOnlyCookie(CookieName.ACCESS_TOKEN.name, accessToken))
        response.addCookie(jwtService.createHttpOnlyCookie(CookieName.REFRESH_TOKEN.name, refreshToken))

        tokenService.saveRefreshToken(user, refreshToken)

        return AuthResponseDTO(
            accessToken = accessToken,
            issuedAt = LocalDateTime.now(),
            accessExpiresAt = LocalDateTime.now().plusSeconds(jwtConfig.expiration),
            refreshToken = refreshToken,
            refreshExpiresAt = LocalDateTime.now().plusSeconds(jwtConfig.refreshExpiration)
        )
    }
}
```

=== Файл: service/impl/PasswordRecoveryServiceImpl.kt ===
```kotlin
package ru.animaltracker.authservice.service.impl

import org.springframework.stereotype.Service
import ru.animaltracker.authservice.entity.User
import ru.animaltracker.authservice.exception.GlobalExceptionHandler
import ru.animaltracker.authservice.service.PasswordRecoveryHelper
import ru.animaltracker.authservice.service.interfaces.PasswordRecoveryService
import ru.animaltracker.authservice.service.interfaces.UserService

@Service
class PasswordRecoveryServiceImpl(
    private val userService: UserService,
    private val passwordRecoveryHelper: ru.animaltracker.authservice.service.PasswordRecoveryHelper
) : PasswordRecoveryService {

    override fun initiatePasswordRecovery(identifier: String) {
        val user: User = if (identifier.contains("@")) {
            userService.findByEmail(identifier)
                ?: throw GlobalExceptionHandler.UserNotFoundException("User with email $identifier not found")
        } else {
            userService.findByUsername(identifier)
                ?: throw GlobalExceptionHandler.UserNotFoundException("User with username $identifier not found")
        }
        val recoveryToken: String = passwordRecoveryHelper.generateAndSaveRecoveryToken(user)
        passwordRecoveryHelper.sendRecoveryEmail(user, recoveryToken)
    }

    override fun resetPassword(token: String, newPassword: String) {
        passwordRecoveryHelper.resetPassword(token, newPassword)
    }
}
```

=== Файл: service/impl/ActivationServiceImpl.kt ===
```kotlin
package ru.animaltracker.authservice.service.impl

import org.springframework.stereotype.Service
import ru.animaltracker.authservice.entity.MailToken
import ru.animaltracker.authservice.entity.User
import ru.animaltracker.authservice.enums.MailTokenType
import ru.animaltracker.authservice.repository.MailTokenRepository
import ru.animaltracker.authservice.config.EmailConfig
import ru.animaltracker.authservice.dto.UserCreatedEvent
import ru.animaltracker.authservice.enums.EmailTemplateName
import ru.animaltracker.authservice.exception.GlobalExceptionHandler
//import ru.animaltracker.authservice.kafka.KafkaProducer
import ru.animaltracker.authservice.service.interfaces.ActivationService
import ru.animaltracker.authservice.service.EmailService
import ru.animaltracker.authservice.service.MessageProducerService
import ru.animaltracker.authservice.service.interfaces.UserService
import java.security.SecureRandom
import java.time.LocalDateTime

@Service
class ActivationServiceImpl(
    private val mailTokenRepository: MailTokenRepository,
    private val userService: UserService,
    private val emailService: EmailService,
    private val emailConfig: EmailConfig,
    private val messageProducerService: MessageProducerService
) : ActivationService {

    override fun generateAndSaveActivationToken(user: User): String {
        deactivateExistingTokens(user, MailTokenType.CONFIRM)

        val generatedToken = generateActivationCode()
        val mailToken = MailToken(
            token = generatedToken,
            createdAt = LocalDateTime.now(),
            expiresAt = LocalDateTime.now().plusSeconds(emailConfig.activationTokenExpiration),
            user = user,
            tokenType = MailTokenType.CONFIRM
        )
        mailTokenRepository.save(mailToken)
        return generatedToken
    }

    override fun activateAccount(token: String) {
        val savedMailToken: MailToken = mailTokenRepository.findByToken(token)
            ?: throw GlobalExceptionHandler.InvalidTokenException("Invalid activation token")

        if (LocalDateTime.now().isAfter(savedMailToken.expiresAt) || !savedMailToken.enabled) {
            throw GlobalExceptionHandler.InvalidTokenException("Activation token expired or already used")
        }

        val user = savedMailToken.user
        userService.enableUser(user)
        savedMailToken.validatedAt = LocalDateTime.now()
        savedMailToken.enabled = false
        mailTokenRepository.save(savedMailToken)

    }

    override fun sendActivationEmail(user: User, token: String) {
        emailService.sendEmail(
            to = user.email,
            username = user.username,
            emailTemplate = EmailTemplateName.ACTIVATE_ACCOUNT,
            confirmationUrl = emailConfig.activationUrl,
            activationCode = token,
            subject = "Account Activation"
        )
    }

    private fun deactivateExistingTokens(user: User, tokenType: MailTokenType) {
        val activeTokens = mailTokenRepository.findByUserIdAndEnabledAndTokenType(
            userId = user.id!!,
            enabled = true,
            tokenType = tokenType
        )
        activeTokens.forEach { it.enabled = false }
        mailTokenRepository.saveAll(activeTokens)
    }

    private fun generateActivationCode(length: Int = 6): String {
//        val secureRandom = SecureRandom()
//        return (1..length)
//            .map { secureRandom.nextInt(10) }
//            .joinToString("")
        return "777777"
    }
}
```

=== Файл: service/impl/TokenServiceImpl.kt ===
```kotlin
package ru.animaltracker.authservice.service.impl

import jakarta.servlet.http.HttpServletResponse
import org.springframework.stereotype.Service
import ru.animaltracker.authservice.config.JwtConfig
import ru.animaltracker.authservice.dto.AuthResponseDTO
import ru.animaltracker.authservice.entity.Token
import ru.animaltracker.authservice.entity.User
import ru.animaltracker.authservice.enums.CookieName
import ru.animaltracker.authservice.enums.TokenType
import ru.animaltracker.authservice.exception.GlobalExceptionHandler
import ru.animaltracker.authservice.repository.TokenRepository
import ru.animaltracker.authservice.service.JwtService
import ru.animaltracker.authservice.service.interfaces.TokenService
import ru.animaltracker.authservice.service.interfaces.UserService
import java.time.LocalDateTime

@Service
class TokenServiceImpl(
    private val tokenRepository: TokenRepository,
    private val userService: UserService,
    private val jwtService: ru.animaltracker.authservice.service.JwtService,
    private val jwtConfig: ru.animaltracker.authservice.config.JwtConfig,
) : TokenService {

    override fun saveRefreshToken(user: User, refreshToken: String) {
        val token = Token(
            user = user,
            token = refreshToken,
            tokenType = TokenType.REFRESH,
            expired = false,
            revoked = false,
            created = LocalDateTime.now()
        )
        tokenRepository.save(token)
    }

    override fun revokeRefreshToken(token: String) {
        val storedToken = tokenRepository.findByToken(token)
        storedToken?.let {
            it.revoked = true
            it.expired = true
            tokenRepository.save(it)
        }
    }

    override fun findRefreshToken(token: String): Token? = tokenRepository.findByToken(token)

    override fun revokeAllRefreshTokens(user: User) {
        val tokens = tokenRepository.findValidRefreshTokensByUser(user.id!!)
        tokens.forEach {
            it.revoked = true
            it.expired = true
        }
        tokenRepository.saveAll(tokens)
    }

    override fun refreshToken(refreshToken: String, response: HttpServletResponse): AuthResponseDTO {
        if (!jwtService.isRefreshTokenValid(refreshToken)) {
            throw GlobalExceptionHandler.InvalidTokenException("Invalid or expired refresh token")
        }

        val userEmail: String = jwtService.extractUsername(refreshToken)
            ?: throw GlobalExceptionHandler.InvalidTokenException("Invalid refresh token")

        val user: User = userService.findByEmail(userEmail)
            ?: throw GlobalExceptionHandler.InvalidTokenException("User not found")

        revokeRefreshToken(refreshToken)
        val newRefreshToken: String = jwtService.generateRefreshToken(user)
        saveRefreshToken(user, newRefreshToken)

        val newAccessToken: String = jwtService.generateAccessToken(user)

        response.addCookie(jwtService.createHttpOnlyCookie(CookieName.ACCESS_TOKEN.name, newAccessToken))
        response.addCookie(jwtService.createHttpOnlyCookie(CookieName.REFRESH_TOKEN.name, newRefreshToken))

        return AuthResponseDTO(
            accessToken = newAccessToken,
            issuedAt = LocalDateTime.now(),
            accessExpiresAt = LocalDateTime.now().plusSeconds(jwtConfig.expiration),
            refreshToken = newRefreshToken,
            refreshExpiresAt = LocalDateTime.now().plusSeconds(jwtConfig.refreshExpiration)
        )
    }
}
```

=== Файл: service/impl/RegistrationServiceImpl.kt ===
```kotlin
package ru.animaltracker.authservice.service.impl

import org.springframework.stereotype.Service
import ru.animaltracker.authservice.dto.UserCreatedEvent
//import ru.animaltracker.authservice.kafka.KafkaProducer
import ru.animaltracker.authservice.service.interfaces.ActivationService
import ru.animaltracker.authservice.service.interfaces.RegistrationService
import ru.animaltracker.authservice.service.interfaces.UserService
import ru.animaltracker.authservice.dto.UserRequestDTO
import ru.animaltracker.authservice.dto.UserResponseDTO
import ru.animaltracker.authservice.service.MessageProducerService
import java.time.LocalDateTime

@Service
class RegistrationServiceImpl(
    private val userService: UserService,
    private val activationService: ActivationService,
    private val messageProducerService: MessageProducerService
) : RegistrationService {

    override fun register(request: UserRequestDTO): UserResponseDTO {

        val rawPassword = request.password ?: throw IllegalArgumentException("Password is required")

        val user = userService.registerUser(
            email = request.email,
            username = request.username,
            rawPassword = rawPassword
        )

        val activationToken = activationService.generateAndSaveActivationToken(user)

        activationService.sendActivationEmail(user, activationToken)
        val kal = UserCreatedEvent(
            user.username,
            user.email,
        )
        messageProducerService.sendMessage("user-created", kal)
        // TODO( ДЛЯ ТЕСТОВ ИЗМЕНИТЬ ЛОГИКУ)...

        return UserResponseDTO(
            role = user.roles,
            provider = user.provider,
            enabled = user.enabled,
            createdAt = LocalDateTime.now(),
            updatedAt = LocalDateTime.now()
        )
    }

}
```

=== Файл: service/interfaces/AuthenticationService.kt ===
```kotlin
package ru.animaltracker.authservice.service.interfaces

import jakarta.servlet.http.HttpServletResponse
import ru.animaltracker.authservice.dto.AuthRequestDTO
import ru.animaltracker.authservice.dto.AuthResponseDTO

interface AuthenticationService {
    fun authenticate(request: AuthRequestDTO, response: HttpServletResponse): AuthResponseDTO
}
```

=== Файл: service/interfaces/ActivationService.kt ===
```kotlin
package ru.animaltracker.authservice.service.interfaces

import ru.animaltracker.authservice.entity.User

interface ActivationService {
    fun generateAndSaveActivationToken(user: User): String
    fun activateAccount(token: String)
    fun sendActivationEmail(user: User, token: String)
}
```

=== Файл: service/interfaces/UserService.kt ===
```kotlin
package ru.animaltracker.authservice.service.interfaces

import ru.animaltracker.authservice.dto.UserRequestDTO
import ru.animaltracker.authservice.dto.UserResponseDTO
import ru.animaltracker.authservice.entity.Role
import ru.animaltracker.authservice.entity.User
import ru.animaltracker.authservice.exception.GlobalExceptionHandler

interface UserService {

    fun saveUser(user: User): User
    fun saveRole(role: Role): Role
    fun getUsers(): List<User>

    @Throws(GlobalExceptionHandler.UserAlreadyExistsException::class, IllegalStateException::class)
    fun registerUser(email: String, username: String, rawPassword: String): User

    @Throws(GlobalExceptionHandler.UserAlreadyExistsException::class, IllegalStateException::class)
    fun registerVkUser(userRequest: UserRequestDTO, vkId: Long): User

    fun findByEmail(email: String): User?
    fun findByUsername(username: String): User?
    fun findById(id: Long): User?
    fun findByVkId(vkId: Long): User?
    fun enableUser(user: User)
    fun updatePassword(user: User, newPassword: String)
}
```

=== Файл: service/interfaces/PasswordRecoveryService.kt ===
```kotlin
package ru.animaltracker.authservice.service.interfaces

interface PasswordRecoveryService {
    fun initiatePasswordRecovery(identifier: String)
    fun resetPassword(token: String, newPassword: String)
}
```

=== Файл: service/interfaces/RegistrationService.kt ===
```kotlin
package ru.animaltracker.authservice.service.interfaces

import ru.animaltracker.authservice.dto.UserRequestDTO
import ru.animaltracker.authservice.dto.UserResponseDTO


interface RegistrationService {
    fun register(request: UserRequestDTO): UserResponseDTO
}
```

=== Файл: service/interfaces/TokenService.kt ===
```kotlin
package ru.animaltracker.authservice.service.interfaces

import jakarta.servlet.http.HttpServletResponse
import ru.animaltracker.authservice.dto.AuthResponseDTO
import ru.animaltracker.authservice.entity.Token
import ru.animaltracker.authservice.entity.User

interface TokenService {
    fun saveRefreshToken(user: User, refreshToken: String)
    fun revokeRefreshToken(token: String)
    fun findRefreshToken(token: String): Token?
    fun revokeAllRefreshTokens(user: User)
    fun refreshToken(refreshToken: String, response: HttpServletResponse): AuthResponseDTO
}
```

=== Файл: exception/ExceptionResponse.kt ===
```kotlin
package ru.animaltracker.authservice.exception

import com.fasterxml.jackson.annotation.JsonInclude
import com.fasterxml.jackson.databind.PropertyNamingStrategies
import com.fasterxml.jackson.databind.annotation.JsonNaming

@JsonInclude(JsonInclude.Include.NON_EMPTY)
@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy::class)
data class ExceptionResponse(
    var businessErrorCode: Int? = null,
    var businessErrorDescription : String? = null,
    var error : String? = null,
    var validationErrors: Set<String>? = null,
    var errors: Map<String, String>? = null,
)
```

=== Файл: exception/GlobalExceptionHandler.kt ===
```kotlin
package ru.animaltracker.authservice.exception

import jakarta.mail.MessagingException
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.security.authentication.BadCredentialsException
import org.springframework.security.authentication.DisabledException
import org.springframework.security.authentication.LockedException
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.RestControllerAdvice
import ru.animaltracker.authservice.enums.BusinessErrorCodes

@RestControllerAdvice
class GlobalExceptionHandler {

    class UserAlreadyExistsException(message: String) : RuntimeException(message)
    class InvalidTokenException(message: String) : RuntimeException(message)
    class UserNotFoundException(message: String) : RuntimeException(message)

    @ExceptionHandler(InvalidTokenException::class)
    fun handleInvalidTokenException(exp: InvalidTokenException): ResponseEntity<ru.animaltracker.authservice.exception.ExceptionResponse> =
        ResponseEntity.status(HttpStatus.UNAUTHORIZED)
            .body(
                ru.animaltracker.authservice.exception.ExceptionResponse(
                    businessErrorCode = ru.animaltracker.authservice.enums.BusinessErrorCodes.INVALID_TOKEN.code,
                    businessErrorDescription = ru.animaltracker.authservice.enums.BusinessErrorCodes.INVALID_TOKEN.description,
                    error = exp.message
                )
            )

    @ExceptionHandler(UserNotFoundException::class)
    fun handleUserNotFoundException(exp: UserNotFoundException): ResponseEntity<ru.animaltracker.authservice.exception.ExceptionResponse> =
        ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(
                ru.animaltracker.authservice.exception.ExceptionResponse(
                    businessErrorCode = ru.animaltracker.authservice.enums.BusinessErrorCodes.USER_NOT_FOUND.code,
                    businessErrorDescription = ru.animaltracker.authservice.enums.BusinessErrorCodes.USER_NOT_FOUND.description,
                    error = exp.message
                )
            )

    @ExceptionHandler(UserAlreadyExistsException::class)
    fun handleException (exp: UserAlreadyExistsException): ResponseEntity<ru.animaltracker.authservice.exception.ExceptionResponse> =
        ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body(
                ru.animaltracker.authservice.exception.ExceptionResponse(
                    businessErrorCode = ru.animaltracker.authservice.enums.BusinessErrorCodes.USER_ALREADY_EXISTS.code,
                    businessErrorDescription = ru.animaltracker.authservice.enums.BusinessErrorCodes.USER_ALREADY_EXISTS.description,
                    error = "User with this email / username already exists"
                )
            )

    @ExceptionHandler(LockedException::class)
    fun handleException (exp: LockedException): ResponseEntity<ru.animaltracker.authservice.exception.ExceptionResponse> =
        ResponseEntity.status(HttpStatus.UNAUTHORIZED)
            .body(
                ru.animaltracker.authservice.exception.ExceptionResponse(
                    businessErrorCode = ru.animaltracker.authservice.enums.BusinessErrorCodes.ACCOUNT_LOCKED.code,
                    businessErrorDescription = ru.animaltracker.authservice.enums.BusinessErrorCodes.ACCOUNT_LOCKED.description,
                    error = exp.message
                )
            )
    @ExceptionHandler(DisabledException::class)
    fun handleException (exp: DisabledException): ResponseEntity<ru.animaltracker.authservice.exception.ExceptionResponse> =
        ResponseEntity.status(HttpStatus.UNAUTHORIZED)
            .body(
                ru.animaltracker.authservice.exception.ExceptionResponse(
                    businessErrorCode = ru.animaltracker.authservice.enums.BusinessErrorCodes.ACCOUNT_DISABLED.code,
                    businessErrorDescription = ru.animaltracker.authservice.enums.BusinessErrorCodes.ACCOUNT_DISABLED.description,
                    error = exp.message
                )
            )

    @ExceptionHandler(BadCredentialsException::class)
    fun handleException (exp: BadCredentialsException): ResponseEntity<ru.animaltracker.authservice.exception.ExceptionResponse> =
        ResponseEntity.status(HttpStatus.UNAUTHORIZED)
            .body(
                ru.animaltracker.authservice.exception.ExceptionResponse(
                    businessErrorCode = ru.animaltracker.authservice.enums.BusinessErrorCodes.BAD_CREDENTIALS.code,
                    businessErrorDescription = ru.animaltracker.authservice.enums.BusinessErrorCodes.BAD_CREDENTIALS.description,
                    error = ru.animaltracker.authservice.enums.BusinessErrorCodes.BAD_CREDENTIALS.description
                )
            )

    @ExceptionHandler(MessagingException::class)
    fun handleException (exp: MessagingException): ResponseEntity<ru.animaltracker.authservice.exception.ExceptionResponse> =
        ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(
                ru.animaltracker.authservice.exception.ExceptionResponse(
                    error = exp.message,
                )
            )

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleException (exp: MethodArgumentNotValidException): ResponseEntity<ru.animaltracker.authservice.exception.ExceptionResponse> {

        val errors: MutableSet<String> = HashSet()
        exp.bindingResult.fieldErrors.forEach { fieldError ->
            fieldError.defaultMessage?.let { errors.add(it) }
        }

        return         ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .body(
                ru.animaltracker.authservice.exception.ExceptionResponse(
                    validationErrors = errors,
                )
            )
    }

    @ExceptionHandler(Exception::class)
    fun handleException (exp: Exception): ResponseEntity<ru.animaltracker.authservice.exception.ExceptionResponse> =
        ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(
                ru.animaltracker.authservice.exception.ExceptionResponse(
                    businessErrorDescription = "Very bad(",
                    error = exp.message
                )
            )
}
```

=== Файл: entity/User.kt ===
```kotlin
package ru.animaltracker.authservice.entity

import jakarta.persistence.*
import org.springframework.data.annotation.CreatedDate
import org.springframework.data.annotation.LastModifiedDate
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import org.springframework.security.core.GrantedAuthority
import org.springframework.security.core.authority.SimpleGrantedAuthority
import org.springframework.security.core.userdetails.UserDetails
import ru.animaltracker.authservice.enums.Provider
import java.security.Principal
import java.time.LocalDateTime

@Entity
@Table(name = "users")
@EntityListeners(AuditingEntityListener::class) // Чтобы дата создания и обновления сразу вбивались при создании юзера
class User(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY) // IDENTITY - По мере заполнения просто инкремент id
    var id: Long? = null,

    @Column(nullable = false, unique = true) var email: String,

    @Column(nullable = false, unique = true)
    private var username: String,

    @Column(nullable = true)
    private var password: String,

    @ManyToMany(fetch = FetchType.LAZY, cascade = [CascadeType.ALL])
    var roles: MutableSet<Role> = mutableSetOf(),

    @OneToMany(mappedBy = "user", cascade = [CascadeType.ALL], orphanRemoval = true)
    private var tokens: MutableSet<Token> = mutableSetOf(),

    @Column(nullable = true) var vkId: Long? = null,

    @Column(nullable = false) var provider: Provider,

    @Column(nullable = false) var enabled: Boolean,

    @Column(nullable = false)
    private var accountLocked: Boolean,

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false) var createdAt: LocalDateTime? = null,

    @LastModifiedDate
    @Column(name = "updated_at")
    private var updatedAt: LocalDateTime? = null

) : UserDetails, Principal{
    override fun getAuthorities(): MutableCollection<out GrantedAuthority> = roles.map { SimpleGrantedAuthority(it.name) }.toMutableSet()

    override fun isEnabled(): Boolean = enabled

    override fun isCredentialsNonExpired(): Boolean = true

    override fun isAccountNonExpired(): Boolean = true

    override fun isAccountNonLocked(): Boolean = !accountLocked

    override fun getPassword(): String = password

    override fun getUsername(): String = username

    override fun getName(): String = username

    fun setPassword(newPassword: String) {
        this.password = newPassword
    }
}
```

=== Файл: entity/Token.kt ===
```kotlin
package ru.animaltracker.authservice.entity

import jakarta.persistence.*
import ru.animaltracker.authservice.enums.TokenType
import java.time.LocalDateTime

@Entity
class Token (
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private var id : Long? = null,

    @Column(unique = true)
    private var token: String,

    @Enumerated(EnumType.STRING)
    var tokenType: TokenType = TokenType.REFRESH,

    var revoked: Boolean,

    var expired: Boolean,

    var created: LocalDateTime = LocalDateTime.now(),

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    var user: User
    )

```

=== Файл: entity/Role.kt ===
```kotlin
package ru.animaltracker.authservice.entity

import com.fasterxml.jackson.annotation.JsonIgnore
import jakarta.persistence.*
import org.springframework.data.annotation.CreatedDate
import org.springframework.data.annotation.LastModifiedDate
import org.springframework.data.jpa.domain.support.AuditingEntityListener
import java.time.LocalDateTime

@Entity
@EntityListeners(AuditingEntityListener::class)
class Role (
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private var id: Long? = null,

    @Column(unique = true, nullable = false)
    var name: String,

    @ManyToMany(fetch = FetchType.LAZY, cascade = [CascadeType.ALL], mappedBy = "roles")
    @JsonIgnore
    private var users: MutableList<User> = mutableListOf(),

    @CreatedDate
    @Column(name = "created_at", updatable = false)
    private var createdAt: LocalDateTime? = null,

    @LastModifiedDate
    @Column(name = "updated_at", insertable = false)
    private var updatedAt: LocalDateTime? = null,

)
```

=== Файл: entity/MailToken.kt ===
```kotlin
package ru.animaltracker.authservice.entity

import jakarta.persistence.*
import ru.animaltracker.authservice.enums.MailTokenType
import java.time.LocalDateTime

@Entity
class MailToken(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long? = null,
    var token: String,
    @Enumerated(EnumType.STRING)
    var tokenType: MailTokenType,
    var expiresAt: LocalDateTime,
    var createdAt: LocalDateTime,
    var validatedAt: LocalDateTime? = null,
    var enabled: Boolean = true,
    @ManyToOne
    @JoinColumn(name = "userId", nullable = false) var user: User
)
```

=== Файл: dto/UserRequestDTO.kt ===
```kotlin
package ru.animaltracker.authservice.dto
import com.fasterxml.jackson.databind.PropertyNamingStrategies
import com.fasterxml.jackson.databind.annotation.JsonNaming
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotEmpty
import jakarta.validation.constraints.Size
import org.springframework.validation.annotation.Validated

@Validated
@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy::class)
data class UserRequestDTO(

    @field:NotEmpty(message = "username cannot be empty")
    @field:NotBlank(message = "username cannot has blank")
    var username: String,

    @field:Email(message = "email is not formatted")
    @field:NotEmpty(message = "email cannot be empty")
    @field:NotBlank(message = "email cannot has blank")
    var email: String,

    var password: String?
)
```

=== Файл: dto/AuthResponseDTO.kt ===
```kotlin
package ru.animaltracker.authservice.dto
import com.fasterxml.jackson.databind.PropertyNamingStrategies
import com.fasterxml.jackson.databind.annotation.JsonNaming
import java.time.Instant
import java.time.LocalDateTime

@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy::class)
data class AuthResponseDTO (
    var accessToken: String,
    var accessExpiresAt: LocalDateTime? = null,
    var issuedAt: LocalDateTime? = null,
    var refreshToken: String? = null,
    var refreshExpiresAt: LocalDateTime? = null,
)
```

=== Файл: dto/UserCreatedEvent.kt ===
```kotlin
package ru.animaltracker.authservice.dto

data class UserCreatedEvent(
    val username: String,
    val email: String,
)
```

=== Файл: dto/PasswordResetRequestDTO.kt ===
```kotlin
package ru.animaltracker.authservice.dto
import com.fasterxml.jackson.databind.PropertyNamingStrategies
import com.fasterxml.jackson.databind.annotation.JsonNaming
import jakarta.validation.constraints.NotBlank
import org.springframework.validation.annotation.Validated

@Validated
@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy::class)
data class PasswordResetRequestDTO(
    @field:NotBlank(message = "Token must not be blank")
    val token: String,

    @field:NotBlank(message = "New password must not be blank")
    val newPassword: String
)
```

=== Файл: dto/AuthRequestDTO.kt ===
```kotlin
package ru.animaltracker.authservice.dto

import com.fasterxml.jackson.databind.PropertyNamingStrategies
import com.fasterxml.jackson.databind.annotation.JsonNaming
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotEmpty
import jakarta.validation.constraints.Size
import org.springframework.validation.annotation.Validated

@Validated
@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy::class)
data class AuthRequestDTO(
    @field:NotBlank
    @field:NotEmpty
    var indentifier: String,

    @field:NotEmpty(message = "password cannot be empty")
    @field:NotBlank(message = "password cannot has blank")
    @field:Size(min = 4, message = "password should be 4 chars long minimum")
    var password: String
)
```

=== Файл: dto/UserResponseDTO.kt ===
```kotlin
package ru.animaltracker.authservice.dto
import com.fasterxml.jackson.databind.PropertyNamingStrategies
import com.fasterxml.jackson.databind.annotation.JsonNaming
import ru.animaltracker.authservice.entity.Role
import ru.animaltracker.authservice.enums.Provider
import ru.animaltracker.authservice.enums.UserRole
import java.time.LocalDateTime

@JsonNaming(PropertyNamingStrategies.SnakeCaseStrategy::class)
data class UserResponseDTO(
    var role: MutableSet<Role>, // Тут поменять
    var provider: Provider,
    var enabled: Boolean,
    var vkId: Long? = null,
    var createdAt: LocalDateTime,
    var updatedAt: LocalDateTime? = null,
    )
```

=== Файл: dto/PasswordRecoveryRequestDTO.kt ===
```kotlin
package ru.animaltracker.authservice.dto
import jakarta.validation.constraints.NotBlank
import org.springframework.validation.annotation.Validated


@Validated
data class PasswordRecoveryRequestDTO(
    @field:NotBlank(message = "Identifier must not be blank")
    val identifier: String
)
```

=== Файл: security/JwtFilter.kt ===
```kotlin
package ru.animaltracker.authservice.security

import io.jsonwebtoken.io.IOException
import jakarta.servlet.FilterChain
import jakarta.servlet.ServletException
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.springframework.http.HttpHeaders
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource
import org.springframework.stereotype.Service
import org.springframework.web.filter.OncePerRequestFilter
import ru.animaltracker.authservice.repository.TokenRepository
import ru.animaltracker.authservice.service.JwtService
@Service
class JwtFilter(
    private val jwtService: ru.animaltracker.authservice.service.JwtService,
    private val userDetailsService: UserDetailsService,
    private val tokenRepository: TokenRepository
): OncePerRequestFilter() {
    @Throws(ServletException::class, IOException::class)
    override fun doFilterInternal(
        request: HttpServletRequest,
        response: HttpServletResponse,
        filterChain: FilterChain
    ) {
        if (request.servletPath.contains("/api/auth")) {
            filterChain.doFilter(request, response)
            return
        }
        val authHeader = request.getHeader(HttpHeaders.AUTHORIZATION)
        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response)
            return
        }
        val jwt = authHeader.substring("Bearer ".length)
        val username = jwtService.extractUsername(jwt)

        // Добавлена проверка что token живет и что не исключен
        val token = tokenRepository.findByToken(jwt)
        val isTokenValid = token?.let { !it.expired && !it.revoked } ?: false

        if (username != null &&
            SecurityContextHolder.getContext().authentication == null) {

            val userDetails: UserDetails = userDetailsService.loadUserByUsername(username)
            if (jwtService.isTokenValid(jwt, userDetails) && isTokenValid) {
                val authToken = UsernamePasswordAuthenticationToken(
                userDetails,
                null,
                userDetails.authorities)
                authToken.details = WebAuthenticationDetailsSource()
                    .buildDetails(request)
                SecurityContextHolder.getContext().authentication = authToken
            }
        }
        filterChain.doFilter(request, response)
    }

}
```

=== Файл: security/UserDetailsServiceImpl.kt ===
```kotlin
package ru.animaltracker.authservice.security

import jakarta.transaction.Transactional
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.core.userdetails.UsernameNotFoundException
import org.springframework.stereotype.Service
import ru.animaltracker.authservice.repository.UserRepository

@Service
class UserDetailsServiceImpl(
    private val userRepository: UserRepository
): UserDetailsService{

    @Transactional
    @Throws(UsernameNotFoundException::class)
    override fun loadUserByUsername(username: String): UserDetails {
        val user = userRepository.findByUsername(username)
            ?: throw UsernameNotFoundException("User with email $username not found")
        return user
    }
}
```

=== Файл: config/EmailConfig.kt ===
```kotlin
package ru.animaltracker.authservice.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.stereotype.Component

@Component
@ConfigurationProperties(prefix = "mailing")
class EmailConfig {
    lateinit var activationUrl: String
    lateinit var emailAddressSender: String
    var activationTokenExpiration: Long = 60
}
```

=== Файл: config/KafkaConfigProps.kt ===
```kotlin
package ru.animaltracker.authservice.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.stereotype.Component

@ConfigurationProperties(prefix = "spring.kafka")
data class KafkaConfigProps(
    val bootstrapServers: String = "",
    val producer: ProducerProps = ProducerProps(),
    val consumer: ConsumerProps = ConsumerProps()
) {
    data class ProducerProps(
        val keySerializer: String = "",
        val valueSerializer: String = ""
    )

    data class ConsumerProps(
        val keyDeserializer: String = "",
        val valueDeserializer: String = "",
        val groupId: String = "",
        val autoOffsetReset: String = "",
        val properties: Map<String, String> = emptyMap()
    )
}
```

=== Файл: config/BeansConfig.kt ===
```kotlin
package ru.animaltracker.authservice.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.AuthenticationProvider
import org.springframework.security.authentication.dao.DaoAuthenticationProvider
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder

@Configuration
class BeansConfig (
    val userDetailsService: UserDetailsService
){

    @Bean
    fun authenticationProvider(): AuthenticationProvider{
        val authProvider = DaoAuthenticationProvider()
        authProvider.setUserDetailsService(userDetailsService)
        authProvider.setPasswordEncoder(passwordEncoder())
        return authProvider
    }
    @Bean
    fun authenticationManager(
        config: AuthenticationConfiguration
    ) : AuthenticationManager =
        config.getAuthenticationManager()

    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()
}
```

=== Файл: config/VkApiConfig.kt ===
```kotlin
package ru.animaltracker.authservice.config
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.stereotype.Component

@Component
@ConfigurationProperties(prefix = "spring.security.oauth2.client")
class VkApiConfig {
    lateinit var registration: Registration
    lateinit var provider: Provider

    data class Registration(
        var vk: ClientRegistration
    )

    data class Provider(
        var vk: ClientProvider
    )

    data class ClientRegistration(
        var clientName: String = "",
        var clientId: String = "",
        var clientSecret: String = "",
        var redirectUri: String = "",
        var authorizationGrantType: String = "",
        var clientAuthenticationMethod: String = "",
        var scope: List<String> = listOf(),
        var provider: String = ""
    )

    data class ClientProvider(
        var authorizationUri: String = "",
        var tokenUri: String = "",
        var userInfoUri: String = "",
        var userNameAttribute: String = ""
    )
}
```

=== Файл: config/KafkaProducerConfig.kt ===
```kotlin
package ru.animaltracker.authservice.config

import org.apache.kafka.clients.producer.ProducerConfig
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.kafka.core.DefaultKafkaProducerFactory
import org.springframework.kafka.core.KafkaTemplate
import org.springframework.kafka.core.ProducerFactory

@Configuration
class KafkaProducerConfig {

    @Bean
    fun producerFactory(): ProducerFactory<String, String> {
        val configProps = mapOf(
            ProducerConfig.BOOTSTRAP_SERVERS_CONFIG to "kafka:9092",
            ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG to "org.apache.kafka.common.serialization.StringSerializer",
            ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG to "org.apache.kafka.common.serialization.StringSerializer"
        )
        return DefaultKafkaProducerFactory(configProps)
    }

    @Bean
    fun kafkaTemplate(): KafkaTemplate<String, String> {
        return KafkaTemplate(producerFactory())
    }
}
```

=== Файл: config/JwtConfig.kt ===
```kotlin
package ru.animaltracker.authservice.config

import jakarta.annotation.PostConstruct
import org.slf4j.LoggerFactory
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.stereotype.Component

@Component
@ConfigurationProperties(prefix = "spring.security.jwt")
class JwtConfig {
    lateinit var secretKey: String
    var expiration: Long = 0
    var refreshExpiration: Long = 0
}
```

=== Файл: config/PublicRoutesConfig.kt ===
```kotlin
package ru.animaltracker.authservice.config

import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.stereotype.Component

@Component
@ConfigurationProperties(prefix = "spring")
class PublicRoutesConfig {
    lateinit var publicUrls: List<String>
}
```

=== Файл: config/WebConfig.kt ===
```kotlin
package ru.animaltracker.authservice.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.client.RestTemplate
import org.springframework.web.servlet.config.annotation.CorsRegistry
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer

@Configuration
class WebConfig {

    @Bean
    fun restTemplate(): RestTemplate = RestTemplate()

    @Bean
    fun corsConfigurer(): WebMvcConfigurer {
        return object : WebMvcConfigurer {
            override fun addCorsMappings(registry: CorsRegistry) {
                registry.addMapping("/**")
                    .allowedOrigins("*")
                    .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH")
                    .allowedHeaders("*")
            }
        }
    }
}
```

=== Файл: config/OpenApiConfig.kt ===
```kotlin
package ru.animaltracker.authservice.config

import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.info.Info
import io.swagger.v3.oas.models.servers.Server
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.util.UriComponentsBuilder

@Configuration
class OpenApiConfig {

    @Bean
    fun customOpenAPI(): OpenAPI {
        return OpenAPI()
            .servers(listOf(Server().url("http://localhost:80")))
            .info(
                Info()
                    .title("Auth Service API")
                    .description("API for hadle register/login/oauth2")
                    .version("v1.0")
            )
    }
}
```

=== Файл: config/SecurityConfig.kt ===
```kotlin
package ru.animaltracker.authservice.config

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.authentication.AuthenticationProvider
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter
import ru.animaltracker.authservice.security.JwtFilter

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(securedEnabled = true)
class SecurityConfig(
    private val jwtAuthFilter: JwtFilter,
    private val authenticationProvider: AuthenticationProvider,
    private val publicRoutesConfig: PublicRoutesConfig
) {
    @Bean
    @Throws(Exception::class)
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .csrf { it.disable() }
            .sessionManagement { session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            }
            .authorizeHttpRequests { authorize ->
                publicRoutesConfig.publicUrls.forEach { url ->
                    authorize.requestMatchers(url).permitAll()
                }

                authorize.anyRequest().authenticated()
            }
            .authenticationProvider(authenticationProvider)
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter::class.java)
        return http.build()
    }
}
```

=== Файл: repository/MailTokenRepository.kt ===
```kotlin
package ru.animaltracker.authservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.authservice.entity.MailToken
import ru.animaltracker.authservice.enums.MailTokenType

interface MailTokenRepository: JpaRepository<MailToken, Long> {
    fun findByToken(token: String): MailToken?
    fun findByUserId(userId: Long): List<MailToken>
    fun findByUserIdAndEnabledAndTokenType(
        userId: Long,
        enabled: Boolean,
        tokenType: MailTokenType
    ): List<MailToken>
}
```

=== Файл: repository/TokenRepository.kt ===
```kotlin
package ru.animaltracker.authservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query
import ru.animaltracker.authservice.entity.Token
import ru.animaltracker.authservice.enums.TokenType

interface TokenRepository : JpaRepository<Token, Long> {
    @Query(
        value = """
        select t from Token t
        where t.user.email = :email and t.expired = false and t.revoked = false
        """
    )
    fun findAllValidTokenByUserEmail (email: String):Set<Token>

    @Query(
        value = """
        select t from Token t inner join User u
        on t.user.id = u.id
        where u.id = :id and t.expired = false and t.revoked = false
        """
    )
    fun findAllValidTokenByUser (id: Long):Set<Token>

    @Query("SELECT t FROM Token t " +
            "WHERE t.user.id = :userId AND t.expired = false AND t.revoked = false AND t.tokenType = 'REFRESH'")
    fun findValidRefreshTokensByUser(userId: Long): Set<Token>

    fun findByToken (token: String): Token?
}
```

=== Файл: repository/UserRepository.kt ===
```kotlin
package ru.animaltracker.authservice.repository

import org.springframework.data.jpa.repository.EntityGraph
import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.authservice.entity.User

interface UserRepository: JpaRepository<User, Long> {
    @EntityGraph(attributePaths = ["roles"])
    fun findByEmail(email: String): User?

    @EntityGraph(attributePaths = ["roles"])
    fun findByUsername(username: String): User?

    @EntityGraph(attributePaths = ["roles"])
    fun findByVkId(vkId: Long): User?
}
```

=== Файл: repository/RoleRepository.kt ===
```kotlin
package ru.animaltracker.authservice.repository

import org.springframework.data.jpa.repository.JpaRepository
import ru.animaltracker.authservice.entity.Role


interface RoleRepository: JpaRepository<Role, Long> {
    fun findByName(name: String): Role?
}
```

Файловая структура frontend:
```
user@archlinux ~/P/p/frontend (main)> cd src
user@archlinux ~/P/p/f/src (main)> tree
.
├── api
│   └── client.ts
├── App.css
├── App.tsx
├── features
│   ├── animal
│   │   ├── api
│   │   │   ├── analyticsApi.ts
│   │   │   ├── animalApi.ts
│   │   │   ├── exportApi.ts
│   │   │   └── types.ts
│   │   └── hooks
│   │       ├── useAnalytics.ts
│   │       ├── useAnimalAttributes.ts
│   │       ├── useAnimal.ts
│   │       ├── useExport.ts
│   │       └── useUserAnimals.ts
│   ├── auth
│   │   ├── api
│   │   │   ├── authApi.ts
│   │   │   └── types.ts
│   │   └── hooks
│   │       ├── useAuth.ts
│   │       └── useToken.ts
│   ├── diary
│   │   ├── api
│   │   │   ├── diaryApi.ts
│   │   │   └── types.ts
│   │   └── hooks
│   │       ├── useDiaryAttributes.ts
│   │       ├── useDiaryFiles.ts
│   │       └── useDiary.ts
│   └── user
│       ├── api
│       │   ├── types.ts
│       │   └── userApi.ts
│       └── hooks
│           └── useUser.ts
├── index.css
├── main.tsx
├── styles
│   └── base.css
└── vite-env.d.ts

16 directories, 28 files
```

Важно: Используй трехуровненвую архитектуру, я хочу чтобы все компоненты были в папке src/components И каждая подпапка отвечала за свой компонент, затем папка src/containers если будет необходимо создать слой контейнер для каких либо компонентов (также организовано в виде подпапок)
Файлы стилей должны находится рядом с файлами компонентов к которым они относятся
Дальше отправлю примерный Figma макет (в нем есть нереализованные части, можешь сам додумать реализации и примерные расположения компонентов)
Делать адаптивную верстку под мобильные устройства не требуется